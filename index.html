// Применяем интерполяцию
                    applyEasing(motionEffect, effects.easingType, effects.bezierP1, effects.bezierP2);
                }
                
                function applyCapcutEffects(clip, effects, clipIndex) {
                    // Проверяем нужно ли применять эффект к этому клипу
                    if (!shouldApplyEffect(clipIndex, effects)) return;
                    
                    var motionEffect = null;
                    for (var i = 0; i < clip.components.numItems; i++) {
                        if (clip.components[i].displayName === "Motion") {
                            motionEffect = clip.components[i];
                            break;
                        }
                    }
                    
                    if (!motionEffect) return;
                    
                    var scaleParam = motionEffect.properties.getParamForDisplayName("Scale");
                    var positionParam = motionEffect.properties.getParamForDisplayName("Position");
                    var rotationParam = motionEffect.properties.getParamForDisplayName("Rotation");
                    
                    var startTime = clip.inPoint.seconds;
                    var endTime = clip.outPoint.seconds;
                    var duration = endTime - startTime;
                    
                    // Выбираем случайный эффект
                    var allEffects = effects.capcutEffects.concat(effects.motionEffects || []);
                    var selectedEffect = allEffects[Math.floor(Math.random() * allEffects.length)];
                    
                    switch(selectedEffect) {
                        case 'zoomBurst':
                            if (scaleParam) {
                                var burstDuration = duration * 0.2; // 20% времени на burst
                                var startScale = effects.zoomBurstStart || 150;
                                var decay = (effects.zoomBurstDecay || 80) / 100;
                                
                                // Быстрый зум в начале
                                scaleParam.addKey(startTime);
                                scaleParam.setValueAtKey(startTime, startScale);
                                
                                // Точка затухания
                                scaleParam.addKey(startTime + burstDuration);
                                scaleParam.setValueAtKey(startTime + burstDuration, 100 + (startScale - 100) * (1 - decay));
                                
                                // Медленное движение до конца
                                scaleParam.addKey(endTime);
                                scaleParam.setValueAtKey(endTime, 100);
                                
                                // Применяем кривую для первого участка
                                setKeyframeInterpolation(scaleParam, 0, 'ease-out');
                                setKeyframeInterpolation(scaleParam, 1, 'linear');
                            }
                            break;
                            
                        case 'pulse':
                            if (scaleParam) {
                                var amplitude = effects.scaleAmplitude / 100;
                                var pulseCount = Math.floor(duration * 2); // 2 пульсации в секунду
                                
                                for (var p = 0; p <= pulseCount; p++) {
                                    var time = startTime + (duration * p / pulseCount);
                                    scaleParam.addKey(time);
                                    
                                    // Чередуем масштаб
                                    var scale = p % 2 === 0 ? 100 : 100 + (20 * amplitude);
                                    scaleParam.setValueAtKey(time, scale);
                                }
                            }
                            break;
                            
                        case 'bounce':
                            if (scaleParam) {
                                var bounceHeight = effects.scaleAmplitude / 100;
                                var bounces = 3;
                                
                                scaleParam.addKey(startTime);
                                scaleParam.setValueAtKey(startTime, 100);
                                
                                for (var b = 1; b <= bounces; b++) {
                                    var bounceTime = startTime + (duration * b / (bounces + 1));
                                    var bounceScale = 100 + (30 * bounceHeight * (1 - b/bounces));
                                    
                                    scaleParam.addKey(bounceTime - 0.1);
                                    scaleParam.setValueAtKey(bounceTime - 0.1, bounceScale);
                                    
                                    scaleParam.addKey(bounceTime);
                                    scaleParam.setValueAtKey(bounceTime, 100);
                                }
                            }
                            break;
                            
                        case 'shake':
                            if (positionParam) {
                                var intensity = effects.motionIntensity / 1000;
                                var shakeFrames = 10;
                                
                                for (var s = 0; s < shakeFrames; s++) {
                                    var shakeTime = startTime + (duration * s / shakeFrames);
                                    var offsetX = (Math.random() - 0.5) * intensity;
                                    var offsetY = (Math.random() - 0.5) * intensity;
                                    
                                    positionParam.addKey(shakeTime);
                                    positionParam.setValueAtKey(shakeTime, [0.5 + offsetX, 0.5 + offsetY]);
                                }
                            }
                            break;
                            
                        case 'wobble':
                            if (rotationParam) {
                                var wobbleAngle = effects.motionIntensity / 10;
                                var wobbleCount = Math.floor(duration * 3);
                                
                                for (var w = 0; w <= wobbleCount; w++) {
                                    var wobbleTime = startTime + (duration * w / wobbleCount);
                                    var angle = Math.sin(w * Math.PI) * wobbleAngle;
                                    
                                    rotationParam.addKey(wobbleTime);
                                    rotationParam.setValueAtKey(wobbleTime, angle);
                                }
                            }
                            break;
                            
                        case 'pendulum':
                            if (rotationParam) {
                                var swingAngle = effects.motionIntensity / 5;
                                
                                rotationParam.addKey(startTime);
                                rotationParam.setValueAtKey(startTime, -swingAngle);
                                
                                rotationParam.addKey(startTime + duration/2);
                                rotationParam.setValueAtKey(startTime + duration/2, swingAngle);
                                
                                rotationParam.addKey(endTime);
                                rotationParam.setValueAtKey(endTime, -swingAngle);
                                
                                // Применяем ease-in-out для плавности
                                setKeyframeInterpolation(rotationParam, 0, 'ease-in-out');
                                setKeyframeInterpolation(rotationParam, 1, 'ease-in-out');
                            }
                            break;
                    }
                }
                
                function shouldApplyEffect(clipIndex, effects) {
                    var frequency = effects.effectFrequency || 'all';
                    
                    if (frequency === 'all') return true;
                    
                    if (frequency === 'percent') {
                        var percent = effects.effectPercent || 50;
                        return Math.random() * 100 < percent;
                    }
                    
                    if (frequency === 'every') {
                        var every = effects.effectEvery || 3;
                        return clipIndex % every === 0;
                    }
                    
                    if (frequency === 'random') {
                        return Math.random() > 0.5;
                    }
                    
                    return false;
                }
                
                function applyColorCorrection(clip, effects) {
                    // Находим или добавляем Lumetri Color
                    var lumetriEffect = null;
                    
                    for (var i = 0; i < clip.components.numItems; i++) {
                        if (clip.components[i].displayName === "Lumetri Color") {
                            lumetriEffect = clip.components[i];
                            break;
                        }
                    }
                    
                    if (!lumetriEffect) {
                        // Добавляем эффект
                        var videoEffects = app.project.rootItem.getVideoEffectByName("Lumetri Color");
                        if (videoEffects) {
                            clip.addVideoEffect(videoEffects);
                            
                            // Находим добавленный эффект
                            for (var j = 0; j < clip.components.numItems; j++) {
                                if (clip.components[j].displayName === "Lumetri Color") {
                                    lumetriEffect = clip.components[j];
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (!lumetriEffect || !lumetriEffect.properties) return;
                    
                    // Применяем настройки цветового фильтра
                    var filterPresets = {
                        'warm': {temperature: 20, tint: 5, saturation: 110},
                        'cold': {temperature: -20, tint: -5, saturation: 90},
                        'vintage': {temperature: 10, tint: 10, saturation: 80, fadeAmount: 10},
                        'blackwhite': {saturation: 0},
                        'sepia': {temperature: 30, tint: 15, saturation: 50},
                        'cinematic': {temperature: -10, contrast: 110, highlights: -20, shadows: 20, saturation: 95},
                        'vibrant': {vibrance: 130, saturation: 120},
                        'faded': {fadeAmount: 15, contrast: 90, saturation: 85}
                    };
                    
                    var preset = filterPresets[effects.colorFilter];
                    if (preset) {
                        for (var param in preset) {
                            setLumetriParam(lumetriEffect, param, preset[param]);
                        }
                    }
                    
                    // Виньетка
                    if (effects.vignette) {
                        var vignetteAmount = -(effects.vignetteIntensity / 100) * 2;
                        setLumetriParam(lumetriEffect, "vignetteAmount", vignetteAmount);
                    }
                    
                    // Зерно
                    if (effects.grain) {
                        // Добавляем эффект Noise
                        var noiseEffect = app.project.rootItem.getVideoEffectByName("Noise");
                        if (noiseEffect) {
                            clip.addVideoEffect(noiseEffect);
                            
                            // Настраиваем интенсивность
                            for (var k = 0; k < clip.components.numItems; k++) {
                                if (clip.components[k].displayName === "Noise") {
                                    var noiseComp = clip.components[k];
                                    var amountParam = noiseComp.properties.getParamForDisplayName("Amount of Noise");
                                    if (amountParam) {
                                        amountParam.setValue(effects.grainIntensity / 100 * 10);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
                
                function setLumetriParam(lumetriEffect, paramName, value) {
                    var properties = lumetriEffect.properties;
                    
                    // Маппинг имен параметров
                    var paramMap = {
                        'temperature': 'Temperature',
                        'tint': 'Tint',
                        'exposure': 'Exposure',
                        'contrast': 'Contrast',
                        'highlights': 'Highlights',
                        'shadows': 'Shadows',
                        'whites': 'Whites',
                        'blacks': 'Blacks',
                        'saturation': 'Saturation',
                        'vibrance': 'Vibrance',
                        'fadeAmount': 'Faded Film Amount',
                        'vignetteAmount': 'Vignette Amount'
                    };
                    
                    var displayName = paramMap[paramName];
                    if (!displayName) return;
                    
                    var param = properties.getParamForDisplayName(displayName);
                    if (param && !param.isTimeVarying()) {
                        param.setValue(value);
                    }
                }
                
                function apply3DEffects(clip, effects) {
                    if (effects.type3D === 'basic') {
                        // Используем Basic 3D эффект
                        var basic3D = app.project.rootItem.getVideoEffectByName("Basic 3D");
                        if (basic3D) {
                            clip.addVideoEffect(basic3D);
                            
                            // Находим добавленный эффект
                            for (var i = 0; i < clip.components.numItems; i++) {
                                if (clip.components[i].displayName === "Basic 3D") {
                                    var effect3D = clip.components[i];
                                    var intensity = effects.intensity3D / 100;
                                    
                                    // Анимируем поворот
                                    var tiltParam = effect3D.properties.getParamForDisplayName("Tilt");
                                    var swivelParam = effect3D.properties.getParamForDisplayName("Swivel");
                                    
                                    if (tiltParam && swivelParam) {
                                        var startTime = clip.inPoint.seconds;
                                        var endTime = clip.outPoint.seconds;
                                        
                                        if (effects.autoRotate3D) {
                                            // Автовращение
                                            swivelParam.addKey(startTime);
                                            swivelParam.setValueAtKey(startTime, -10 * intensity);
                                            swivelParam.addKey(endTime);
                                            swivelParam.setValueAtKey(endTime, 10 * intensity);
                                        } else {
                                            // Статичный 3D
                                            tiltParam.setValue(5 * intensity);
                                            swivelParam.setValue(8 * intensity);
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
                
                function addTransition(clip1, clip2, effects) {
                    var track = clip1.parentTrack;
                    if (!track) return;
                    
                    var transitions = effects.transitions || ['fade'];
                    var selectedTransition = effects.transRandomize ? 
                        transitions[Math.floor(Math.random() * transitions.length)] :
                        transitions[0];
                    
                    var duration = effects.transitionDuration || 1.0;
                    
                    // Маппинг имен переходов
                    var transitionMap = {
                        'fade': 'Dip to Black',
                        'dissolve': 'Cross Dissolve',
                        'dip_black': 'Dip to Black',
                        'dip_white': 'Dip to White',
                        'wipe': 'Linear Wipe',
                        'slide': 'Slide',
                        'push': 'Push',
                        'zoom': 'Cross Zoom'
                    };
                    
                    var transitionName = transitionMap[selectedTransition] || 'Cross Dissolve';
                    
                    // Применяем переход
                    var transition = track.getTransitionByName(transitionName);
                    if (transition) {
                        // Позиция перехода - между клипами
                        var transitionTime = clip1.outPoint.seconds - duration/2;
                        track.insertTransition(transition, transitionTime);
                        
                        // Настраиваем длительность
                        var addedTransition = track.transitions[track.transitions.numItems - 1];
                        if (addedTransition) {
                            addedTransition.duration = duration;
                        }
                    }
                }
                
                function addOverlays(sequence, overlaySettings, totalDuration) {
                    if (!overlaySettings.files || overlaySettings.files.length === 0) return;
                    
                    var videoTrack2 = sequence.videoTracks[1];
                    if (!videoTrack2) return;
                    
                    var currentTime = 0;
                    
                    while (currentTime < totalDuration) {
                        // Выбираем оверлей
                        var overlayFile = overlaySettings.randomize ?
                            overlaySettings.files[Math.floor(Math.random() * overlaySettings.files.length)] :
                            overlaySettings.files[currentTime % overlaySettings.files.length];
                        
                        // Находим в проекте
                        var overlayItem = findProjectItem(overlayFile);
                        if (!overlayItem) continue;
                        
                        // Добавляем на второй трек
                        var overlayClip = videoTrack2.insertClip(overlayItem, currentTime);
                        if (!overlayClip) continue;
                        
                        // Настраиваем наложение
                        var opacityEffect = null;
                        for (var i = 0; i < overlayClip.components.numItems; i++) {
                            if (overlayClip.components[i].displayName === "Opacity") {
                                opacityEffect = overlayClip.components[i];
                                break;
                            }
                        }
                        
                        if (opacityEffect) {
                            var opacityParam = opacityEffect.properties.getParamForDisplayName("Opacity");
                            if (opacityParam) {
                                opacityParam.setValue(overlaySettings.opacity);
                            }
                        }
                        
                        // Режим наложения
                        setBlendMode(overlayClip, overlaySettings.blendMode);
                        
                        // Растягивание
                        if (overlaySettings.stretch) {
                            // Растягиваем на весь кадр
                            var motionEffect = null;
                            for (var j = 0; j < overlayClip.components.numItems; j++) {
                                if (overlayClip.components[j].displayName === "Motion") {
                                    motionEffect = overlayClip.components[j];
                                    break;
                                }
                            }
                            
                            if (motionEffect) {
                                var scaleParam = motionEffect.properties.getParamForDisplayName("Scale");
                                if (scaleParam) {
                                    // Подгоняем под размер кадра
                                    scaleParam.setValue(120); // Немного больше для перекрытия
                                }
                            }
                        }
                        
                        currentTime += overlayClip.duration.seconds;
                    }
                }
                
                function setBlendMode(clip, mode) {
                    // В Premiere Pro режимы наложения устанавливаются через специальное свойство
                    // Это зависит от версии API
                    try {
                        var blendModeMap = {
                            'normal': 0,
                            'screen': 3,
                            'overlay': 9,
                            'multiply': 1,
                            'add': 2,
                            'lighten': 5,
                            'darken': 4
                        };
                        
                        var modeValue = blendModeMap[mode] || 0;
                        
                        // Попытка установить режим наложения
                        if (clip.setBlendMode) {
                            clip.setBlendMode(modeValue);
                        }
                    } catch(e) {
                        // Игнорируем если метод недоступен
                    }
                }
                
                function applyEasing(effect, easingType, bezierP1, bezierP2) {
                    // Применяем интерполяцию ко всем ключевым кадрам
                    if (!effect || !effect.properties) return;
                    
                    for (var i = 0; i < effect.properties.numItems; i++) {
                        var param = effect.properties[i];
                        if (param.isTimeVarying() && param.getKeys().length > 0) {
                            for (var k = 0; k < param.getKeys().length; k++) {
                                setKeyframeInterpolation(param, k, easingType, bezierP1, bezierP2);
                            }
                        }
                    }
                }
                
                function setKeyframeInterpolation(param, keyIndex, easingType, bezierP1, bezierP2) {
                    try {
                        // В Premiere Pro интерполяция устанавливается через временную интерполяцию
                        var key = param.getKeys()[keyIndex];
                        if (!key) return;
                        
                        switch(easingType) {
                            case 'linear':
                                param.setInterpolationTypeAtKey(key.time, KeyframeInterpolationType.LINEAR);
                                break;
                            case 'ease':
                            case 'ease-in-out':
                                param.setInterpolationTypeAtKey(key.time, KeyframeInterpolationType.BEZIER);
                                param.setTemporalEaseAtKey(key.time, [0.33], [0.33]);
                                break;
                            case 'ease-in':
                                param.setInterpolationTypeAtKey(key.time, KeyframeInterpolationType.BEZIER);
                                param.setTemporalEaseAtKey(key.time, [0.42], [0]);
                                break;
                            case 'ease-out':
                                param.setInterpolationTypeAtKey(key.time, KeyframeInterpolationType.BEZIER);
                                param.setTemporalEaseAtKey(key.time, [0], [0.58]);
                                break;
                            case 'bezier':
                                param.setInterpolationTypeAtKey(key.time, KeyframeInterpolationType.BEZIER);
                                var p1 = (bezierP1 || 25) / 100;
                                var p2 = (bezierP2 || 75) / 100;
                                param.setTemporalEaseAtKey(key.time, [p1], [p2]);
                                break;
                        }
                    } catch(e) {
                        // Игнорируем ошибки интерполяции
                    }
                }
            `;
        }

        // === НАСТРОЙКИ ===

        function loadSettings() {
            const stored = localStorage.getItem('autoMontageSettings');
            if (stored) {
                try {
                    const settings = JSON.parse(stored);
                    
                    document.getElementById('ffmpegPath').value = settings.ffmpegPath || 'ffmpeg.exe';
                    document.getElementById('amePath').value = settings.amePath || '';
                    document.getElementById('pythonPath').value = settings.pythonPath || 'python';
                    document.getElementById('renderThreads').value = settings.renderThreads || 4;
                    document.getElementById('renderThreadsValue').textContent = settings.renderThreads || 4;
                    document.getElementById('useGPU').checked = settings.useGPU !== false;
                    document.getElementById('useProxies').checked = settings.useProxies || false;
                    document.getElementById('preRenderEffects').checked = settings.preRenderEffects || false;
                    document.getElementById('transcodeRussian').checked = settings.transcodeRussian !== false;
                    document.getElementById('keepOriginals').checked = settings.keepOriginals !== false;
                    document.getElementById('cleanupTemp').checked = settings.cleanupTemp || false;
                    document.getElementById('autoSave').checked = settings.autoSave !== false;
                    document.getElementById('autoBackup').checked = settings.autoBackup || false;
                    document.getElementById('showNotifications').checked = settings.showNotifications !== false;
                } catch(e) {
                    log('Ошибка загрузки настроек: ' + e.message, 'warning');
                }
            }
            
            // Автопоиск программ
            findMediaEncoder();
        }

        function saveSettings() {
            const settings = {
                ffmpegPath: document.getElementById('ffmpegPath').value,
                amePath: document.getElementById('amePath').value,
                pythonPath: document.getElementById('pythonPath').value,
                renderThreads: parseInt(document.getElementById('renderThreads').value),
                useGPU: document.getElementById('useGPU').checked,
                useProxies: document.getElementById('useProxies').checked,
                preRenderEffects: document.getElementById('preRenderEffects').checked,
                transcodeRussian: document.getElementById('transcodeRussian').checked,
                keepOriginals: document.getElementById('keepOriginals').checked,
                cleanupTemp: document.getElementById('cleanupTemp').checked,
                autoSave: document.getElementById('autoSave').checked,
                autoBackup: document.getElementById('autoBackup').checked,
                showNotifications: document.getElementById('showNotifications').checked
            };
            
            localStorage.setItem('autoMontageSettings', JSON.stringify(settings));
            log('Настройки сохранены', 'info');
        }

        function resetSettings() {
            if (confirm('Сбросить все настройки к значениям по умолчанию?')) {
                localStorage.removeItem('autoMontageSettings');
                loadSettings();
                log('Настройки сброшены', 'info');
            }
        }

        function exportSettings() {
            const allSettings = {
                app: JSON.parse(localStorage.getItem('autoMontageSettings') || '{}'),
                channels: channels,
                version: '4.0.0'
            };
            
            const dataStr = JSON.stringify(allSettings, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = 'automontage_complete_settings_' + new Date().toISOString().slice(0, 10) + '.json';
            link.click();
            
            log('Все настройки экспортированы', 'info');
        }

        function importSettings() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const settings = JSON.parse(event.target.result);
                        
                        if (settings.app) {
                            localStorage.setItem('autoMontageSettings', JSON.stringify(settings.app));
                            loadSettings();
                        }
                        
                        if (settings.channels) {
                            channels = settings.channels;
                            saveChannels();
                            updateChannelLists();
                        }
                        
                        alert('Настройки успешно импортированы!');
                        log('Настройки импортированы', 'info');
                    } catch (err) {
                        alert('Ошибка импорта: ' + err.message);
                        log('Ошибка импорта настроек', 'error');
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }

        function browsePath(type) {
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                
                let filter = '';
                let title = '';
                
                switch(type) {
                    case 'ffmpeg':
                        filter = 'ffmpeg.exe';
                        title = 'Выберите ffmpeg.exe';
                        break;
                    case 'ame':
                        filter = 'Adobe Media Encoder.exe';
                        title = 'Выберите Adobe Media Encoder.exe';
                        break;
                    case 'python':
                        filter = 'python.exe';
                        title = 'Выберите python.exe';
                        break;
                }
                
                const extScript = `
                    var file = File.openDialog("${title}", "${filter}");
                    if (file) {
                        file.fsName;
                    } else {
                        null;
                    }
                `;
                
                csInterface.evalScript(extScript, function(result) {
                    if (result && result !== 'null') {
                        document.getElementById(`${type}Path`).value = result;
                        log(`Выбран путь ${type}: ${result}`, 'info');
                    }
                });
            } else {
                alert('Выбор файла доступен только в Premiere Pro');
            }
        }

        function findMediaEncoder() {
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                
                const extScript = `
                    function findAME() {
                        var paths = [
                            "C:/Program Files/Adobe/Adobe Media Encoder 2024/Adobe Media Encoder.exe",
                            "C:/Program Files/Adobe/Adobe Media Encoder 2023/Adobe Media Encoder.exe",
                            "C:/Program Files/Adobe/Adobe Media Encoder 2022/Adobe Media Encoder.exe",
                            "C:/Program Files/Adobe/Adobe Media Encoder CC 2020/Adobe Media Encoder.exe"
                        ];
                        
                        for (var i = 0; i < paths.length; i++) {
                            var file = new File(paths[i]);
                            if (file.exists) {
                                return paths[i];
                            }
                        }
                        
                        return "";
                    }
                    
                    findAME();
                `;
                
                csInterface.evalScript(extScript, function(result) {
                    if (result && result !== '""') {
                        document.getElementById('amePath').value = result;
                        log('Media Encoder найден автоматически', 'info');
                    }
                });
            }
        }

        function downloadFFmpeg() {
            window.open('https://ffmpeg.org/download.html', '_blank');
            log('Открыта страница загрузки FFmpeg', 'info');
        }

        function checkPython() {
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                const pythonPath = document.getElementById('pythonPath').value;
                
                const extScript = `
                    function checkPython(path) {
                        try {
                            var result = system.callSystem('"' + path + '" --version');
                            return "Python найден: " + result;
                        } catch(e) {
                            return "Python не найден или недоступен";
                        }
                    }
                    
                    checkPython("${pythonPath}");
                `;
                
                cs            document.getElementById('effectFrequency').value = preset.effectFrequency || 'all';
            
            // Обновляем видимость настроек частоты
            document.getElementById('percentSettings').style.display = preset.effectFrequency === 'percent' ? 'block' : 'none';
            document.getElementById('everySettings').style.display = preset.effectFrequency === 'every' ? 'block' : 'none';
            
            if (preset.effectPercent !== undefined) {
                document.getElementById('effectPercent').value = preset.effectPercent;
                document.getElementById('effectPercentValue').textContent = preset.effectPercent + '%';
            }
            
            if (preset.effectEvery !== undefined) {
                document.getElementById('effectEvery').value = preset.effectEvery;
            }
            
            log(`Применен пресет CapCut эффектов: ${presetType}`, 'info');
        }

        // === ГЕНЕРАЦИЯ МОНТАЖА ===

        function testMontage() {
            if (!PROJECT_FOLDER) {
                alert("Сначала выберите папку проекта!");
                return;
            }
            
            log('Запуск тестовой генерации (1 пара файлов)', 'info');
            
            // Создаем временный канал для теста
            const testChannel = {
                id: 'test_channel',
                name: 'Тестовый канал',
                export: {
                    resolution: '1920x1080',
                    fps: 30,
                    bitrate: 8,
                    codec: 'h264'
                },
                effects: {
                    kenBurns: ['zoomIn'],
                    kenBurnsIntensity: 30,
                    transitions: ['fade'],
                    transitionDuration: 1.0,
                    audioPitch: '0',
                    audioEffect: 'none',
                    audioNormalize: true
                }
            };
            
            selectedChannels.clear();
            selectedChannels.add('test_channel');
            
            generateMontage(true);
        }

        function importFiles() {
            if (!PROJECT_FOLDER) {
                alert("Сначала выберите папку проекта!");
                return;
            }
            
            updateProgress(0, "Импорт файлов...");
            log("Начинаем импорт файлов в проект", 'info');
            
            const includeVideos = document.getElementById('includeVideos').checked;
            
            const extScript = `
                function importProjectFiles(folderPath, includeVideos) {
                    try {
                        var project = app.project;
                        if (!project) return "ERROR: Нет активного проекта";
                        
                        var folder = new Folder(folderPath);
                        if (!folder.exists) return "ERROR: Папка не существует";
                        
                        var importBin = project.rootItem.createBin("Auto Montage Import " + new Date().toLocaleString());
                        var files = folder.getFiles();
                        var importedCount = 0;
                        
                        var supportedImageFormats = ['.jpg', '.jpeg', '.png', '.tiff', '.bmp'];
                        var supportedVideoFormats = ['.mp4', '.mov', '.avi', '.mkv'];
                        var supportedAudioFormats = ['.mp3', '.wav', '.aiff', '.m4a', '.flac'];
                        
                        var filesToImport = [];
                        
                        for (var i = 0; i < files.length; i++) {
                            if (files[i] instanceof File) {
                                var ext = files[i].name.substr(files[i].name.lastIndexOf('.')).toLowerCase();
                                
                                if (supportedImageFormats.indexOf(ext) > -1 || 
                                    supportedAudioFormats.indexOf(ext) > -1 ||
                                    (includeVideos && supportedVideoFormats.indexOf(ext) > -1)) {
                                    filesToImport.push(files[i].fsName);
                                    importedCount++;
                                }
                            }
                        }
                        
                        if (filesToImport.length > 0) {
                            project.importFiles(filesToImport, false, importBin, false);
                        }
                        
                        return "SUCCESS: Импортировано " + importedCount + " файлов";
                        
                    } catch(e) {
                        return "ERROR: " + e.toString();
                    }
                }
                
                importProjectFiles("${PROJECT_FOLDER.replace(/\\/g, '\\\\')}", ${includeVideos});
            `;
            
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                csInterface.evalScript(extScript, function(result) {
                    if (result.indexOf("SUCCESS") === 0) {
                        updateProgress(100, "Файлы импортированы");
                        log(result, 'info');
                    } else {
                        updateProgress(0, "Ошибка импорта");
                        log(result, 'error');
                    }
                });
            } else {
                setTimeout(() => {
                    updateProgress(100, "Файлы импортированы (симуляция)");
                    log("Импортировано 15 файлов (симуляция)", 'info');
                }, 1500);
            }
        }

        async function generateMontage(testMode = false) {
            if (!PROJECT_FOLDER) {
                alert("Сначала выберите папку проекта!");
                return;
            }
            
            if (!testMode && selectedChannels.size === 0) {
                alert("Выберите хотя бы один канал для генерации!");
                return;
            }
            
            // Проверяем результат сканирования
            if (!window.lastScanResult || !window.lastScanResult.pairs || window.lastScanResult.pairs.length === 0) {
                alert("Не найдено пар файлов для монтажа! Проверьте нумерацию файлов (0001, 0002...)");
                return;
            }
            
            isGenerating = true;
            generationAborted = false;
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('cancelButton').classList.add('show');
            
            const channelsToProcess = testMode ? 
                [{id: 'test_channel', name: 'Тест', export: {resolution: '1920x1080', fps: 30, bitrate: 8, codec: 'h264'}, effects: {}}] : 
                Array.from(selectedChannels).map(id => channels.find(c => c.id === id)).filter(Boolean);
            
            log(`Начинаем генерацию для ${channelsToProcess.length} каналов`, 'info');
            
            // Подготовка аудио файлов если нужно
            if (document.getElementById('processAudioFirst').checked) {
                await prepareAudioFiles(channelsToProcess);
                
                if (generationAborted) {
                    finishGeneration();
                    return;
                }
            }
            
            // Генерация для каждого канала
            let channelIndex = 0;
            for (const channel of channelsToProcess) {
                if (generationAborted) break;
                
                channelIndex++;
                updateProgress(
                    (channelIndex / channelsToProcess.length) * 100,
                    `Генерация для канала: ${channel.name}`
                );
                
                await generateChannelMontage(channel, testMode);
            }
            
            finishGeneration();
        }

        function finishGeneration() {
            isGenerating = false;
            document.getElementById('generateBtn').disabled = false;
            document.getElementById('cancelButton').classList.remove('show');
            updateProgress(100, generationAborted ? "Генерация отменена" : "Генерация завершена!");
            log(generationAborted ? "Генерация отменена пользователем" : "Генерация завершена успешно", 
                generationAborted ? 'warning' : 'info');
        }

        function cancelGeneration() {
            if (confirm('Отменить генерацию?')) {
                generationAborted = true;
                log('Отмена генерации...', 'warning');
            }
        }

        async function prepareAudioFiles(channelsToProcess) {
            return new Promise((resolve) => {
                updateProgress(10, "Подготовка аудио файлов...");
                
                // Собираем уникальные настройки аудио
                const audioVariants = new Set();
                channelsToProcess.forEach(channel => {
                    const pitch = channel.effects.audioPitch || '0';
                    const effect = channel.effects.audioEffect || 'none';
                    audioVariants.add(`${pitch}_${effect}`);
                });
                
                log(`Необходимо создать ${audioVariants.size} аудио вариантов`, 'info');
                
                const transcodeRussian = document.getElementById('transcodeRussian').checked;
                
                const extScript = `
                    function prepareAudioVariants(folderPath, variants, transcodeRussian) {
                        try {
                            var variantsFolder = new Folder(folderPath + "/audio_variants");
                            if (!variantsFolder.exists) variantsFolder.create();
                            
                            // Создаем bat файл для обработки
                            var batContent = '@echo off\\n';
                            batContent += 'echo Starting audio processing...\\n';
                            batContent += 'cd /d "' + folderPath + '"\\n';
                            
                            // Находим все аудио файлы
                            var folder = new Folder(folderPath);
                            var audioFiles = [];
                            var files = folder.getFiles();
                            
                            for (var i = 0; i < files.length; i++) {
                                if (files[i] instanceof File) {
                                    var ext = files[i].name.substr(files[i].name.lastIndexOf('.')).toLowerCase();
                                    if (['.mp3', '.wav', '.m4a', '.flac'].indexOf(ext) > -1) {
                                        audioFiles.push(files[i]);
                                    }
                                }
                            }
                            
                            // Генерируем команды для каждого файла и варианта
                            for (var j = 0; j < audioFiles.length; j++) {
                                var audioFile = audioFiles[j];
                                var baseName = audioFile.name.substr(0, audioFile.name.lastIndexOf('.'));
                                
                                // Обработка русских имен если нужно
                                var inputName = audioFile.name;
                                var outputBaseName = baseName;
                                
                                if (transcodeRussian && /[а-яА-Я]/.test(inputName)) {
                                    // Транслитерация или использование номера
                                    var number = baseName.match(/^\\d+/);
                                    outputBaseName = number ? 'audio_' + number[0] : 'audio_' + j;
                                }
                                
                                for (var k = 0; k < variants.length; k++) {
                                    var parts = variants[k].split('_');
                                    var pitch = parts[0];
                                    var effect = parts[1];
                                    
                                    var outputName = outputBaseName + '_pitch_' + pitch.replace('+', 'plus').replace('.', '_');
                                    if (effect !== 'none') outputName += '_' + effect;
                                    outputName += '.mp3';
                                    
                                    // FFmpeg команда
                                    batContent += 'ffmpeg -i "' + inputName + '" ';
                                    
                                    // Pitch
                                    if (pitch !== '0') {
                                        var semitones = parseFloat(pitch) * 100;
                                        batContent += '-af "asetrate=44100*pow(2,' + pitch + '/12),aresample=44100';
                                    } else {
                                        batContent += '-af "';
                                    }
                                    
                                    // Эффекты
                                    if (effect === 'bass') {
                                        batContent += ',bass=g=10';
                                    } else if (effect === 'reverb') {
                                        batContent += ',aecho=0.8:0.9:40:0.4';
                                    } else if (effect === 'echo') {
                                        batContent += ',aecho=0.8:0.7:60:0.5';
                                    }
                                    
                                    batContent += '" -b:a 192k "audio_variants/' + outputName + '" -y\\n';
                                }
                            }
                            
                            batContent += 'echo Audio processing completed\\n';
                            batContent += 'pause\\n';
                            
                            // Сохраняем и запускаем bat файл
                            var batFile = new File(folderPath + '/process_audio.bat');
                            batFile.open('w');
                            batFile.write(batContent);
                            batFile.close();
                            
                            // Запускаем
                            batFile.execute();
                            
                            return "SUCCESS: Bat файл создан и запущен";
                            
                        } catch(e) {
                            return "ERROR: " + e.toString();
                        }
                    }
                    
                    var variants = ${JSON.stringify(Array.from(audioVariants))};
                    prepareAudioVariants("${PROJECT_FOLDER.replace(/\\/g, '\\\\')}", variants, ${transcodeRussian});
                `;
                
                if (typeof CSInterface !== 'undefined') {
                    const csInterface = new CSInterface();
                    csInterface.evalScript(extScript, function(result) {
                        log(result, result.startsWith('SUCCESS') ? 'info' : 'error');
                        
                        // Ждем немного для обработки
                        setTimeout(resolve, 3000);
                    });
                } else {
                    setTimeout(() => {
                        log("Аудио файлы подготовлены (симуляция)", 'info');
                        resolve();
                    }, 2000);
                }
            });
        }

        async function generateChannelMontage(channel, testMode = false) {
            return new Promise((resolve) => {
                log(`Создание монтажа для канала: ${channel.name}`, 'info');
                
                const pairs = testMode ? 
                    window.lastScanResult.pairs.slice(0, 1) : // Только первая пара для теста
                    window.lastScanResult.pairs;
                
                const config = {
                    channelName: channel.name.replace(/[^a-zA-Z0-9]/g, '_'), // Безопасное имя
                    channelId: channel.id,
                    export: channel.export,
                    effects: channel.effects,
                    overlays: channel.overlays,
                    projectFolder: PROJECT_FOLDER,
                    audioVariantsFolder: AUDIO_VARIANTS_FOLDER,
                    pairs: pairs,
                    testMode: testMode
                };
                
                const extScript = `
                    ${getMontageFunctions()}
                    
                    try {
                        var config = ${JSON.stringify(config)};
                        var result = createChannelMontage(config);
                        JSON.stringify(result);
                    } catch(e) {
                        JSON.stringify({success: false, error: e.toString()});
                    }
                `;
                
                if (typeof CSInterface !== 'undefined') {
                    const csInterface = new CSInterface();
                    csInterface.evalScript(extScript, function(result) {
                        try {
                            const response = JSON.parse(result);
                            if (response.success) {
                                log(`Монтаж для канала "${channel.name}" создан`, 'info');
                            } else {
                                log(`Ошибка создания монтажа: ${response.error}`, 'error');
                            }
                        } catch(e) {
                            log('Ошибка обработки результата: ' + e.message, 'error');
                        }
                        resolve();
                    });
                } else {
                    setTimeout(() => {
                        log(`Монтаж для канала "${channel.name}" создан (симуляция)`, 'info');
                        resolve();
                    }, 3000);
                }
            });
        }

        function getMontageFunctions() {
            return `
                function createChannelMontage(config) {
                    var project = app.project;
                    if (!project) {
                        return {success: false, error: "Нет активного проекта"};
                    }
                    
                    try {
                        // Создаем секвенцию
                        var sequenceName = "Montage_" + config.channelName + "_" + new Date().getTime();
                        
                        // Получаем правильный пресет
                        var presetPath = getSequencePreset(config.export);
                        var sequence = project.createNewSequence(sequenceName, presetPath);
                        
                        if (!sequence) {
                            return {success: false, error: "Не удалось создать секвенцию"};
                        }
                        
                        // Основная функция построения монтажа
                        var result = buildMontageSequence(sequence, config);
                        
                        if (!result.success) {
                            return result;
                        }
                        
                        return {
                            success: true, 
                            sequenceName: sequenceName,
                            clipsAdded: result.clipsAdded
                        };
                        
                    } catch(e) {
                        return {success: false, error: "createChannelMontage: " + e.toString()};
                    }
                }
                
                function getSequencePreset(exportSettings) {
                    // Возвращаем ID пресета в зависимости от настроек
                    if (exportSettings.resolution === '1920x1080') {
                        return ""; // Стандартный HD пресет
                    } else if (exportSettings.resolution === '3840x2160') {
                        return ""; // 4K пресет
                    } else if (exportSettings.resolution === '1080x1920') {
                        return ""; // Вертикальный пресет
                    }
                    return ""; // По умолчанию
                }
                
                function buildMontageSequence(sequence, config) {
                    try {
                        var videoTrack = sequence.videoTracks[0];
                        var audioTrack = sequence.audioTracks[0];
                        
                        if (!videoTrack || !audioTrack) {
                            return {success: false, error: "Не удалось получить доступ к трекам"};
                        }
                        
                        var currentTime = 0;
                        var clipsAdded = 0;
                        var previousClip = null;
                        
                        // Обрабатываем каждую пару файлов
                        for (var i = 0; i < config.pairs.length; i++) {
                            var pair = config.pairs[i];
                            
                            // Находим медиа файл в проекте
                            var mediaItem = findProjectItem(pair.mediaFile.name);
                            var audioItem = findAudioVariant(pair.audioFile.name, config);
                            
                            if (!mediaItem || !audioItem) {
                                $.writeln("Пропускаем пару " + pair.number + ": файлы не найдены в проекте");
                                continue;
                            }
                            
                            // Добавляем на таймлайн
                            var videoClip = videoTrack.insertClip(mediaItem, currentTime);
                            var audioClip = audioTrack.insertClip(audioItem, currentTime);
                            
                            if (!videoClip || !audioClip) {
                                continue;
                            }
                            
                            // Синхронизируем длительность
                            var audioDuration = audioClip.duration.seconds;
                            
                            // Для видео файлов - обрабатываем зацикливание
                            if (pair.mediaType === 'video' && videoClip.duration.seconds < audioDuration) {
                                handleVideoLooping(videoClip, audioDuration, videoTrack, currentTime);
                            } else {
                                // Для изображений или длинных видео - просто устанавливаем длительность
                                videoClip.end = videoClip.start + audioDuration;
                            }
                            
                            // Применяем эффекты
                            applyClipEffects(videoClip, config, i);
                            
                            // Добавляем переход если есть предыдущий клип
                            if (previousClip && config.effects.transitions && config.effects.transitions.length > 0) {
                                addTransition(previousClip, videoClip, config.effects);
                            }
                            
                            previousClip = videoClip;
                            currentTime += audioDuration;
                            clipsAdded++;
                        }
                        
                        // Добавляем оверлеи если нужно
                        if (config.overlays && config.overlays.enabled && config.overlays.files.length > 0) {
                            addOverlays(sequence, config.overlays, currentTime);
                        }
                        
                        return {success: true, clipsAdded: clipsAdded};
                        
                    } catch(e) {
                        return {success: false, error: "buildMontageSequence: " + e.toString()};
                    }
                }
                
                function findProjectItem(fileName) {
                    // Рекурсивный поиск элемента в проекте
                    function searchInBin(bin, name) {
                        for (var i = 0; i < bin.children.numItems; i++) {
                            var item = bin.children[i];
                            if (item.type === ProjectItemType.BIN) {
                                var found = searchInBin(item, name);
                                if (found) return found;
                            } else if (item.name === name) {
                                return item;
                            }
                        }
                        return null;
                    }
                    
                    return searchInBin(app.project.rootItem, fileName);
                }
                
                function findAudioVariant(originalName, config) {
                    // Сначала ищем обработанный вариант
                    var baseName = originalName.substr(0, originalName.lastIndexOf('.'));
                    var pitch = config.effects.audioPitch || '0';
                    var effect = config.effects.audioEffect || 'none';
                    
                    var variantName = baseName + '_pitch_' + pitch.replace('+', 'plus').replace('.', '_');
                    if (effect !== 'none') variantName += '_' + effect;
                    variantName += '.mp3';
                    
                    var variant = findProjectItem(variantName);
                    if (variant) return variant;
                    
                    // Если не нашли - возвращаем оригинал
                    return findProjectItem(originalName);
                }
                
                function handleVideoLooping(videoClip, targetDuration, videoTrack, startTime) {
                    var clipDuration = videoClip.duration.seconds;
                    var currentTime = startTime;
                    var sourceItem = videoClip.projectItem;
                    
                    // Устанавливаем длительность первого клипа
                    videoClip.end = videoClip.start + Math.min(clipDuration, targetDuration);
                    currentTime += clipDuration;
                    
                    // Добавляем копии пока не достигнем нужной длительности
                    while (currentTime < startTime + targetDuration) {
                        var remainingTime = (startTime + targetDuration) - currentTime;
                        var nextClip = videoTrack.insertClip(sourceItem, currentTime);
                        
                        if (nextClip) {
                            if (remainingTime < clipDuration) {
                                // Обрезаем последний клип
                                nextClip.end = nextClip.start + remainingTime;
                            }
                            
                            // Добавляем плавный переход
                            var transition = videoTrack.getTransitionByName("Cross Dissolve");
                            if (transition) {
                                var transitionDuration = 0.5; // 0.5 секунды
                                videoTrack.insertTransition(transition, currentTime - transitionDuration/2);
                            }
                            
                            currentTime += Math.min(clipDuration, remainingTime);
                        } else {
                            break;
                        }
                    }
                }
                
                function applyClipEffects(clip, config, clipIndex) {
                    if (!clip || !clip.isValid()) return;
                    
                    var effects = config.effects;
                    
                    // Ken Burns эффекты
                    if (effects.kenBurns && effects.kenBurns.length > 0) {
                        applyKenBurns(clip, effects, clipIndex);
                    }
                    
                    // CapCut эффекты
                    if (effects.capcutEffects && effects.capcutEffects.length > 0) {
                        applyCapcutEffects(clip, effects, clipIndex);
                    }
                    
                    // Цветокоррекция
                    if (effects.colorCorrection) {
                        applyColorCorrection(clip, effects);
                    }
                    
                    // 3D эффекты
                    if (effects.enable3D) {
                        apply3DEffects(clip, effects);
                    }
                }
                
                function applyKenBurns(clip, effects, clipIndex) {
                    var motionEffect = null;
                    
                    // Ищем Motion эффект
                    for (var i = 0; i < clip.components.numItems; i++) {
                        if (clip.components[i].displayName === "Motion") {
                            motionEffect = clip.components[i];
                            break;
                        }
                    }
                    
                    if (!motionEffect) return;
                    
                    // Выбираем эффект
                    var selectedEffect = effects.kbRandomize ? 
                        effects.kenBurns[Math.floor(Math.random() * effects.kenBurns.length)] :
                        effects.kenBurns[clipIndex % effects.kenBurns.length];
                    
                    var intensity = effects.kenBurnsIntensity / 100;
                    var startTime = clip.inPoint.seconds;
                    var endTime = clip.outPoint.seconds;
                    
                    // Получаем параметры
                    var scaleParam = motionEffect.properties.getParamForDisplayName("Scale");
                    var positionParam = motionEffect.properties.getParamForDisplayName("Position");
                    var rotationParam = motionEffect.properties.getParamForDisplayName("Rotation");
                    
                    // Умная обрезка - увеличиваем начальный масштаб для компенсации
                    var cropCompensation = effects.smartCrop ? 1.1 : 1.0;
                    
                    switch(selectedEffect) {
                        case 'zoomIn':
                            if (scaleParam) {
                                scaleParam.addKey(startTime);
                                scaleParam.setValueAtKey(startTime, 100 * cropCompensation);
                                scaleParam.addKey(endTime);
                                scaleParam.setValueAtKey(endTime, (100 + 30 * intensity) * cropCompensation);
                            }
                            break;
                            
                        case 'zoomOut':
                            if (scaleParam) {
                                scaleParam.addKey(startTime);
                                scaleParam.setValueAtKey(startTime, (100 + 30 * intensity) * cropCompensation);
                                scaleParam.addKey(endTime);
                                scaleParam.setValueAtKey(endTime, 100 * cropCompensation);
                            }
                            break;
                            
                        case 'panLeft':
                        case 'panRight':
                        case 'panUp':
                        case 'panDown':
                            if (positionParam && scaleParam) {
                                // Увеличиваем масштаб для умной обрезки
                                scaleParam.setValue(110 * cropCompensation);
                                
                                var direction = selectedEffect.replace('pan', '').toLowerCase();
                                var moveAmount = 0.1 * intensity;
                                
                                positionParam.addKey(startTime);
                                positionParam.addKey(endTime);
                                
                                var startPos = [0.5, 0.5];
                                var endPos = [0.5, 0.5];
                                
                                if (direction === 'left') endPos[0] -= moveAmount;
                                else if (direction === 'right') endPos[0] += moveAmount;
                                else if (direction === 'up') endPos[1] -= moveAmount;
                                else if (direction === 'down') endPos[1] += moveAmount;
                                
                                positionParam.setValueAtKey(startTime, startPos);
                                positionParam.setValueAtKey(endTime, endPos);
                            }
                            break;
                            
                        case 'rotate':
                            if (rotationParam && scaleParam) {
                                // Увеличиваем масштаб еще больше для компенсации углов
                                var rotationScale = 1 + (effects.rotationAngle / 90);
                                scaleParam.setValue(100 * cropCompensation * rotationScale);
                                
                                rotationParam.addKey(startTime);
                                rotationParam.setValueAtKey(startTime, -effects.rotationAngle / 2);
                                rotationParam.addKey(endTime);
                                rotationParam.setValueAtKey(endTime, effects.rotationAngle / 2);
                            }
                            break;
                            
                        case 'diagonal':
                            if (positionParam && scaleParam) {
                                scaleParam.setValue(120 * cropCompensation);
                                
                                positionParam.addKey(startTime);
                                positionParam.setValueAtKey(startTime, [0.4, 0.4]);
                                positionParam.addKey(endTime);
                                positionParam.setValueAtKey(endTime, [0.6, 0.6]);
                            }
                            break;
                    }
                    
                    // Применяем интерполяцию
                    applyEasing(motionEffect, effects.easing                    transitionDuration: 0.5,
                    capcutEffects: ['zoomBurst', 'bounce', 'shake'],
                    effectFrequency: 'percent',
                    effectPercent: 50
                },
                cinematic: {
                    name: 'Кинематографичный канал',
                    description: 'Плавные движения, атмосферная обработка',
                    kenBurns: ['zoomIn', 'panRight'],
                    kenBurnsIntensity: 30,
                    transitions: ['fade', 'dissolve'],
                    transitionDuration: 2.0,
                    colorCorrection: true,
                    colorFilter: 'cinematic',
                    vignette: true,
                    vignetteIntensity: 60,
                    grain: true,
                    grainIntensity: 15
                },
                minimal: {
                    name: 'Минималистичный канал',
                    description: 'Простые переходы без лишних эффектов',
                    kenBurns: [],
                    transitions: ['fade'],
                    transitionDuration: 1.0,
                    colorCorrection: false
                },
                retro: {
                    name: 'Ретро канал',
                    description: 'Винтажный стиль с эффектами старой пленки',
                    kenBurns: ['zoomOut', 'panLeft'],
                    kenBurnsIntensity: 20,
                    transitions: ['dip_black', 'dip_white'],
                    transitionDuration: 1.5,
                    colorCorrection: true,
                    colorFilter: 'vintage',
                    vignette: true,
                    vignetteIntensity: 80,
                    grain: true,
                    grainIntensity: 40,
                    audioPitch: '-1',
                    audioEffect: 'vintage'
                }
            };
            
            const template = templates[templateType];
            if (!template) return;
            
            const newChannel = {
                id: 'channel_' + Date.now(),
                name: template.name,
                description: template.description,
                template: 'youtube',
                export: {
                    resolution: '1920x1080',
                    customWidth: 1920,
                    customHeight: 1080,
                    fps: 30,
                    bitrate: 8,
                    codec: 'h264'
                },
                effects: {
                    kenBurns: template.kenBurns || [],
                    kenBurnsIntensity: template.kenBurnsIntensity || 30,
                    rotationAngle: 5,
                    smartCrop: true,
                    kbRandomize: false,
                    transitions: template.transitions || ['fade'],
                    transitionDuration: template.transitionDuration || 1.0,
                    transRandomize: false,
                    colorCorrection: template.colorCorrection || false,
                    colorFilter: template.colorFilter || 'none',
                    vignette: template.vignette || false,
                    vignetteIntensity: template.vignetteIntensity || 40,
                    grain: template.grain || false,
                    grainIntensity: template.grainIntensity || 20,
                    audioPitch: template.audioPitch || '0',
                    audioEffect: template.audioEffect || 'none',
                    audioStereoEnhance: false,
                    audioNormalize: true,
                    easingType: 'ease',
                    bezierP1: 25,
                    bezierP2: 75,
                    enable3D: false,
                    type3D: 'basic',
                    intensity3D: 20,
                    autoRotate3D: false,
                    capcutEffects: template.capcutEffects || [],
                    scaleAmplitude: 15,
                    zoomBurstStart: 150,
                    zoomBurstDecay: 80,
                    motionEffects: [],
                    motionIntensity: 30,
                    effectFrequency: template.effectFrequency || 'all',
                    effectPercent: template.effectPercent || 50,
                    effectEvery: 3,
                    avoidRepetition: true
                },
                overlays: {
                    enabled: false,
                    files: [],
                    blendMode: 'screen',
                    opacity: 100,
                    randomize: false,
                    stretch: true
                }
            };
            
            channels.push(newChannel);
            saveChannels();
            updateChannelLists();
            closeModal('templateModal');
            log(`Создан канал из шаблона: ${template.name}`, 'info');
        }

        function editChannel(channelId) {
            document.querySelector('[data-tab="effects"]').click();
            document.getElementById('channelSelector').value = channelId;
            loadChannelEffects();
        }

        function duplicateChannel(channelId) {
            const channel = channels.find(c => c.id === channelId);
            if (!channel) return;
            
            const newChannel = JSON.parse(JSON.stringify(channel));
            newChannel.id = 'channel_' + Date.now();
            newChannel.name = channel.name + ' (копия)';
            
            channels.push(newChannel);
            saveChannels();
            updateChannelLists();
            log(`Канал "${channel.name}" дублирован`, 'info');
        }

        function deleteChannel(channelId) {
            const channel = channels.find(c => c.id === channelId);
            if (!channel) return;
            
            if (confirm(`Удалить канал "${channel.name}"?`)) {
                channels = channels.filter(c => c.id !== channelId);
                saveChannels();
                updateChannelLists();
                log(`Канал "${channel.name}" удален`, 'info');
            }
        }

        // === РАБОТА С ЭФФЕКТАМИ ===

        function loadChannelEffects() {
            const channelId = document.getElementById('channelSelector').value;
            if (!channelId) {
                document.getElementById('effectsEditor').style.display = 'none';
                return;
            }
            
            const channel = channels.find(c => c.id === channelId);
            if (!channel) return;
            
            currentChannelId = channelId;
            document.getElementById('effectsEditor').style.display = 'block';
            
            const effects = channel.effects;
            const exportSettings = channel.export;
            
            // Настройки экспорта
            document.getElementById('channelResolution').value = exportSettings.resolution || '1920x1080';
            document.getElementById('customResolution').style.display = 
                exportSettings.resolution === 'custom' ? 'block' : 'none';
            document.getElementById('customWidth').value = exportSettings.customWidth || 1920;
            document.getElementById('customHeight').value = exportSettings.customHeight || 1080;
            document.getElementById('channelFps').value = exportSettings.fps || 30;
            document.getElementById('channelBitrate').value = exportSettings.bitrate || 8;
            document.getElementById('channelCodec').value = exportSettings.codec || 'h264';
            
            // Ken Burns
            document.querySelectorAll('.kb-effect').forEach(cb => {
                const effectName = cb.id.replace('kb_', '');
                cb.checked = effects.kenBurns && effects.kenBurns.includes(effectName);
            });
            document.getElementById('kbIntensity').value = effects.kenBurnsIntensity || 30;
            document.getElementById('kbIntensityValue').textContent = (effects.kenBurnsIntensity || 30) + '%';
            document.getElementById('rotationAngle').value = effects.rotationAngle || 5;
            document.getElementById('rotationAngleValue').textContent = (effects.rotationAngle || 5) + '°';
            document.getElementById('kbSmartCrop').checked = effects.smartCrop !== false;
            document.getElementById('kbRandomize').checked = effects.kbRandomize || false;
            
            // Переходы
            document.querySelectorAll('.transition-effect').forEach(cb => {
                const effectName = cb.id.replace('trans_', '');
                cb.checked = effects.transitions && effects.transitions.includes(effectName);
            });
            document.getElementById('transitionDuration').value = effects.transitionDuration || 1.0;
            document.getElementById('transRandomize').checked = effects.transRandomize || false;
            
            // Цветокоррекция
            document.getElementById('enableColorCorrection').checked = effects.colorCorrection || false;
            document.getElementById('colorCorrectionSettings').style.display = effects.colorCorrection ? 'block' : 'none';
            document.getElementById('colorFilter').value = effects.colorFilter || 'none';
            document.getElementById('enableVignette').checked = effects.vignette || false;
            document.getElementById('vignetteSettings').style.display = effects.vignette ? 'block' : 'none';
            document.getElementById('vignetteIntensity').value = effects.vignetteIntensity || 40;
            document.getElementById('vignetteIntensityValue').textContent = (effects.vignetteIntensity || 40) + '%';
            document.getElementById('enableGrain').checked = effects.grain || false;
            document.getElementById('grainSettings').style.display = effects.grain ? 'block' : 'none';
            document.getElementById('grainIntensity').value = effects.grainIntensity || 20;
            document.getElementById('grainIntensityValue').textContent = (effects.grainIntensity || 20) + '%';
            
            // Аудио
            document.getElementById('audioPitch').value = effects.audioPitch || '0';
            document.getElementById('audioEffect').value = effects.audioEffect || 'none';
            document.getElementById('audioStereoEnhance').checked = effects.audioStereoEnhance || false;
            document.getElementById('audioNormalize').checked = effects.audioNormalize !== false;
            
            // Плавность
            document.getElementById('easingType').value = effects.easingType || 'ease';
            document.getElementById('bezierSettings').style.display = effects.easingType === 'bezier' ? 'block' : 'none';
            document.getElementById('bezierP1').value = effects.bezierP1 || 25;
            document.getElementById('bezierP1Value').textContent = effects.bezierP1 || 25;
            document.getElementById('bezierP2').value = effects.bezierP2 || 75;
            document.getElementById('bezierP2Value').textContent = effects.bezierP2 || 75;
            
            // 3D
            document.getElementById('enable3D').checked = effects.enable3D || false;
            document.getElementById('3dSettings').style.display = effects.enable3D ? 'block' : 'none';
            document.getElementById('3dType').value = effects.type3D || 'basic';
            document.getElementById('3dIntensity').value = effects.intensity3D || 20;
            document.getElementById('3dIntensityValue').textContent = (effects.intensity3D || 20) + '%';
            document.getElementById('3dAutoRotate').checked = effects.autoRotate3D || false;
        }

        function saveChannelEffects() {
            if (!currentChannelId) return;
            
            const channel = channels.find(c => c.id === currentChannelId);
            if (!channel) return;
            
            // Собираем настройки экспорта
            const exportSettings = {
                resolution: document.getElementById('channelResolution').value,
                customWidth: parseInt(document.getElementById('customWidth').value),
                customHeight: parseInt(document.getElementById('customHeight').value),
                fps: parseInt(document.getElementById('channelFps').value),
                bitrate: parseInt(document.getElementById('channelBitrate').value),
                codec: document.getElementById('channelCodec').value
            };
            
            // Собираем все эффекты
            const effects = {
                // Ken Burns
                kenBurns: [],
                kenBurnsIntensity: parseInt(document.getElementById('kbIntensity').value),
                rotationAngle: parseInt(document.getElementById('rotationAngle').value),
                smartCrop: document.getElementById('kbSmartCrop').checked,
                kbRandomize: document.getElementById('kbRandomize').checked,
                
                // Переходы
                transitions: [],
                transitionDuration: parseFloat(document.getElementById('transitionDuration').value),
                transRandomize: document.getElementById('transRandomize').checked,
                
                // Цветокоррекция
                colorCorrection: document.getElementById('enableColorCorrection').checked,
                colorFilter: document.getElementById('colorFilter').value,
                vignette: document.getElementById('enableVignette').checked,
                vignetteIntensity: parseInt(document.getElementById('vignetteIntensity').value),
                grain: document.getElementById('enableGrain').checked,
                grainIntensity: parseInt(document.getElementById('grainIntensity').value),
                
                // Аудио
                audioPitch: document.getElementById('audioPitch').value,
                audioEffect: document.getElementById('audioEffect').value,
                audioStereoEnhance: document.getElementById('audioStereoEnhance').checked,
                audioNormalize: document.getElementById('audioNormalize').checked,
                
                // Плавность
                easingType: document.getElementById('easingType').value,
                bezierP1: parseInt(document.getElementById('bezierP1').value),
                bezierP2: parseInt(document.getElementById('bezierP2').value),
                
                // 3D
                enable3D: document.getElementById('enable3D').checked,
                type3D: document.getElementById('3dType').value,
                intensity3D: parseInt(document.getElementById('3dIntensity').value),
                autoRotate3D: document.getElementById('3dAutoRotate').checked
            };
            
            // Собираем выбранные эффекты
            document.querySelectorAll('.kb-effect:checked').forEach(cb => {
                effects.kenBurns.push(cb.id.replace('kb_', ''));
            });
            
            document.querySelectorAll('.transition-effect:checked').forEach(cb => {
                effects.transitions.push(cb.id.replace('trans_', ''));
            });
            
            // Сохраняем старые настройки CapCut эффектов
            if (channel.effects.capcutEffects) {
                effects.capcutEffects = channel.effects.capcutEffects;
                effects.scaleAmplitude = channel.effects.scaleAmplitude;
                effects.zoomBurstStart = channel.effects.zoomBurstStart;
                effects.zoomBurstDecay = channel.effects.zoomBurstDecay;
                effects.motionEffects = channel.effects.motionEffects;
                effects.motionIntensity = channel.effects.motionIntensity;
                effects.effectFrequency = channel.effects.effectFrequency;
                effects.effectPercent = channel.effects.effectPercent;
                effects.effectEvery = channel.effects.effectEvery;
                effects.avoidRepetition = channel.effects.avoidRepetition;
            }
            
            // Сохраняем
            channel.export = exportSettings;
            channel.effects = effects;
            saveChannels();
            log(`Настройки канала "${channel.name}" сохранены`, 'info');
        }

        function resetChannelEffects() {
            if (!currentChannelId) return;
            
            if (confirm('Сбросить все настройки эффектов к значениям по умолчанию?')) {
                loadChannelEffects();
                log('Настройки сброшены', 'info');
            }
        }

        function previewEffects() {
            alert('Предпросмотр будет реализован в следующей версии');
        }

        function duplicateToChannel() {
            if (!currentChannelId) return;
            
            const sourceChannel = channels.find(c => c.id === currentChannelId);
            if (!sourceChannel) return;
            
            const channelNames = channels
                .filter(c => c.id !== currentChannelId)
                .map(c => c.name)
                .join('\n');
            
            const targetName = prompt(`Копировать настройки в канал:\n\n${channelNames}\n\nВведите название канала:`);
            if (!targetName) return;
            
            const targetChannel = channels.find(c => c.name === targetName && c.id !== currentChannelId);
            if (!targetChannel) {
                alert('Канал не найден!');
                return;
            }
            
            targetChannel.effects = JSON.parse(JSON.stringify(sourceChannel.effects));
            targetChannel.export = JSON.parse(JSON.stringify(sourceChannel.export));
            saveChannels();
            log(`Настройки скопированы в канал "${targetName}"`, 'info');
        }

        // === РАБОТА С ОВЕРЛЕЯМИ ===

        function selectOverlaysFolder() {
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                
                const extScript = `
                    var folder = Folder.selectDialog("Выберите папку с оверлеями");
                    if (folder) {
                        folder.fsName;
                    } else {
                        null;
                    }
                `;
                
                csInterface.evalScript(extScript, function(result) {
                    if (result && result !== 'null') {
                        OVERLAYS_FOLDER = result;
                        document.getElementById('overlaysPath').value = result;
                        scanOverlaysFolder();
                    }
                });
            } else {
                OVERLAYS_FOLDER = "C:/Overlays";
                document.getElementById('overlaysPath').value = OVERLAYS_FOLDER;
                
                // Симуляция файлов
                overlayFiles = [
                    {name: 'particles.mp4', type: 'video'},
                    {name: 'film_grain.mov', type: 'video'},
                    {name: 'light_leak.mp4', type: 'video'},
                    {name: 'frame_vintage.png', type: 'image'},
                    {name: 'dust.mp4', type: 'video'}
                ];
                
                log(`Найдено оверлеев: ${overlayFiles.length}`, 'info');
            }
        }

        function scanOverlaysFolder() {
            if (!OVERLAYS_FOLDER) return;
            
            const extScript = `
                function scanOverlays(folderPath) {
                    try {
                        var folder = new Folder(folderPath);
                        if (!folder.exists) return {files: [], error: "Папка не существует"};
                        
                        var overlays = [];
                        var files = folder.getFiles();
                        var supportedFormats = ['.mp4', '.mov', '.avi', '.png', '.gif'];
                        
                        for (var i = 0; i < files.length; i++) {
                            if (files[i] instanceof File) {
                                var fileName = files[i].name;
                                var ext = fileName.substr(fileName.lastIndexOf('.')).toLowerCase();
                                
                                if (supportedFormats.indexOf(ext) > -1) {
                                    var type = (ext === '.png' || ext === '.gif') ? 'image' : 'video';
                                    overlays.push({
                                        name: fileName,
                                        path: files[i].fsName,
                                        type: type
                                    });
                                }
                            }
                        }
                        
                        return {files: overlays};
                        
                    } catch(e) {
                        return {files: [], error: e.toString()};
                    }
                }
                
                JSON.stringify(scanOverlays("${OVERLAYS_FOLDER.replace(/\\/g, '\\\\')}"));
            `;
            
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                csInterface.evalScript(extScript, function(result) {
                    try {
                        const scanResult = JSON.parse(result);
                        overlayFiles = scanResult.files;
                        log(`Найдено оверлеев: ${overlayFiles.length}`, 'info');
                    } catch(e) {
                        log('Ошибка сканирования оверлеев: ' + e.message, 'error');
                    }
                });
            }
        }

        function loadChannelOverlays() {
            const channelId = document.getElementById('overlayChannelSelector').value;
            if (!channelId) {
                document.getElementById('overlaySettings').style.display = 'none';
                return;
            }
            
            const channel = channels.find(c => c.id === channelId);
            if (!channel) return;
            
            document.getElementById('overlaySettings').style.display = 'block';
            
            // Отображаем список оверлеев
            const overlaysList = document.getElementById('overlaysList');
            overlaysList.innerHTML = '';
            
            if (!overlayFiles || overlayFiles.length === 0) {
                overlaysList.innerHTML = '<div class="info-text">Сначала выберите папку с оверлеями</div>';
                return;
            }
            
            overlayFiles.forEach((overlay, index) => {
                const item = document.createElement('div');
                item.className = 'effect-item';
                item.innerHTML = `
                    <input type="checkbox" id="overlay_${index}" class="overlay-file" data-name="${overlay.name}">
                    <label for="overlay_${index}">
                        ${overlay.type === 'video' ? '🎬' : '🖼️'} ${overlay.name}
                    </label>
                `;
                overlaysList.appendChild(item);
            });
            
            // Загружаем сохраненные настройки
            if (channel.overlays) {
                document.getElementById('overlayBlendMode').value = channel.overlays.blendMode || 'screen';
                document.getElementById('overlayOpacity').value = channel.overlays.opacity || 100;
                document.getElementById('overlayOpacityValue').textContent = (channel.overlays.opacity || 100) + '%';
                document.getElementById('overlayRandomize').checked = channel.overlays.randomize || false;
                document.getElementById('overlayStretch').checked = channel.overlays.stretch !== false;
                
                // Отмечаем выбранные файлы
                if (channel.overlays.files) {
                    channel.overlays.files.forEach(fileName => {
                        const checkbox = document.querySelector(`.overlay-file[data-name="${fileName}"]`);
                        if (checkbox) checkbox.checked = true;
                    });
                }
            }
        }

        function saveOverlaySettings() {
            const channelId = document.getElementById('overlayChannelSelector').value;
            if (!channelId) return;
            
            const channel = channels.find(c => c.id === channelId);
            if (!channel) return;
            
            const selectedFiles = [];
            document.querySelectorAll('.overlay-file:checked').forEach(cb => {
                selectedFiles.push(cb.dataset.name);
            });
            
            channel.overlays = {
                enabled: selectedFiles.length > 0,
                files: selectedFiles,
                blendMode: document.getElementById('overlayBlendMode').value,
                opacity: parseInt(document.getElementById('overlayOpacity').value),
                randomize: document.getElementById('overlayRandomize').checked,
                stretch: document.getElementById('overlayStretch').checked
            };
            
            saveChannels();
            updateChannelLists();
            log(`Настройки оверлеев для канала "${channel.name}" сохранены`, 'info');
        }

        // === CAPCUT ЭФФЕКТЫ ===

        function loadChannelCapcutEffects() {
            const channelId = document.getElementById('capcutChannelSelector').value;
            if (!channelId) {
                document.getElementById('capcutEffectsEditor').style.display = 'none';
                return;
            }
            
            const channel = channels.find(c => c.id === channelId);
            if (!channel) return;
            
            document.getElementById('capcutEffectsEditor').style.display = 'block';
            
            const effects = channel.effects;
            
            // Анимации масштаба
            document.querySelectorAll('.capcut-effect').forEach(cb => {
                const effectName = cb.id.replace('fx_', '');
                cb.checked = effects.capcutEffects && effects.capcutEffects.includes(effectName);
            });
            
            document.getElementById('scaleAmplitude').value = effects.scaleAmplitude || 15;
            document.getElementById('scaleAmplitudeValue').textContent = (effects.scaleAmplitude || 15) + '%';
            document.getElementById('zoomBurstStart').value = effects.zoomBurstStart || 150;
            document.getElementById('zoomBurstStartValue').textContent = (effects.zoomBurstStart || 150) + '%';
            document.getElementById('zoomBurstDecay').value = effects.zoomBurstDecay || 80;
            document.getElementById('zoomBurstDecayValue').textContent = (effects.zoomBurstDecay || 80) + '%';
            
            document.getElementById('motionIntensity').value = effects.motionIntensity || 30;
            document.getElementById('motionIntensityValue').textContent = (effects.motionIntensity || 30) + '%';
            
            // Частота применения
            document.getElementById('effectFrequency').value = effects.effectFrequency || 'all';
            document.getElementById('effectPercent').value = effects.effectPercent || 50;
            document.getElementById('effectPercentValue').textContent = (effects.effectPercent || 50) + '%';
            document.getElementById('effectEvery').value = effects.effectEvery || 3;
            document.getElementById('avoidRepetition').checked = effects.avoidRepetition !== false;
            
            // Показываем/скрываем настройки частоты
            const freq = effects.effectFrequency || 'all';
            document.getElementById('percentSettings').style.display = freq === 'percent' ? 'block' : 'none';
            document.getElementById('everySettings').style.display = freq === 'every' ? 'block' : 'none';
        }

        function saveCapcutEffects() {
            const channelId = document.getElementById('capcutChannelSelector').value;
            if (!channelId) return;
            
            const channel = channels.find(c => c.id === channelId);
            if (!channel) return;
            
            const capcutEffects = [];
            const motionEffects = [];
            
            document.querySelectorAll('.capcut-effect:checked').forEach(cb => {
                const effectName = cb.id.replace('fx_', '');
                if (['zoomBurst', 'pulse', 'bounce', 'elastic', 'wave'].includes(effectName)) {
                    capcutEffects.push(effectName);
                } else {
                    motionEffects.push(effectName);
                }
            });
            
            channel.effects.capcutEffects = capcutEffects;
            channel.effects.motionEffects = motionEffects;
            channel.effects.scaleAmplitude = parseInt(document.getElementById('scaleAmplitude').value);
            channel.effects.zoomBurstStart = parseInt(document.getElementById('zoomBurstStart').value);
            channel.effects.zoomBurstDecay = parseInt(document.getElementById('zoomBurstDecay').value);
            channel.effects.motionIntensity = parseInt(document.getElementById('motionIntensity').value);
            channel.effects.effectFrequency = document.getElementById('effectFrequency').value;
            channel.effects.effectPercent = parseInt(document.getElementById('effectPercent').value);
            channel.effects.effectEvery = parseInt(document.getElementById('effectEvery').value);
            channel.effects.avoidRepetition = document.getElementById('avoidRepetition').checked;
            
            saveChannels();
            updateChannelLists();
            log(`CapCut эффекты для канала "${channel.name}" сохранены`, 'info');
        }

        function presetCapcutEffects(presetType) {
            const presets = {
                dynamic: {
                    capcutEffects: ['zoomBurst', 'bounce'],
                    motionEffects: ['shake', 'wobble'],
                    scaleAmplitude: 25,
                    motionIntensity: 40,
                    effectFrequency: 'percent',
                    effectPercent: 60
                },
                smooth: {
                    capcutEffects: ['pulse', 'wave'],
                    motionEffects: ['pendulum'],
                    scaleAmplitude: 10,
                    motionIntensity: 20,
                    effectFrequency: 'every',
                    effectEvery: 3
                },
                epic: {
                    capcutEffects: ['zoomBurst', 'elastic'],
                    motionEffects: ['shake', 'glitch'],
                    scaleAmplitude: 30,
                    zoomBurstStart: 180,
                    zoomBurstDecay: 90,
                    motionIntensity: 50,
                    effectFrequency: 'all'
                }
            };
            
            const preset = presets[presetType];
            if (!preset) return;
            
            // Применяем пресет
            document.querySelectorAll('.capcut-effect').forEach(cb => {
                const effectName = cb.id.replace('fx_', '');
                cb.checked = preset.capcutEffects.includes(effectName) || preset.motionEffects.includes(effectName);
            });
            
            if (preset.scaleAmplitude !== undefined) {
                document.getElementById('scaleAmplitude').value = preset.scaleAmplitude;
                document.getElementById('scaleAmplitudeValue').textContent = preset.scaleAmplitude + '%';
            }
            
            if (preset.zoomBurstStart !== undefined) {
                document.getElementById('zoomBurstStart').value = preset.zoomBurstStart;
                document.getElementById('zoomBurstStartValue').textContent = preset.zoomBurstStart + '%';
            }
            
            if (preset.zoomBurstDecay !== undefined) {
                document.getElementById('zoomBurstDecay').value = preset.zoomBurstDecay;
                document.getElementById('zoomBurstDecayValue').textContent = preset.zoomBurstDecay + '%';
            }
            
            if (preset.motionIntensity !== undefined) {
                document.getElementById('motionIntensity').value = preset.motionIntensity;
                document.getElementById('motionIntensityValue').textContent = preset.motionIntensity + '%';
            }
            
            document.getElementById('effectFrequency').value =                <div class="checkbox-group">
                    <input type="checkbox" id="preRenderEffects">
                    <label for="preRenderEffects">Предварительный рендер сложных эффектов</label>
                </div>
            </div>

            <div class="panel">
                <h3>🌐 Обработка файлов</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="transcodeRussian" checked>
                    <label for="transcodeRussian">Автоматически перекодировать русские названия</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="keepOriginals" checked>
                    <label for="keepOriginals">Сохранять оригинальные файлы</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="cleanupTemp">
                    <label for="cleanupTemp">Удалять временные файлы после генерации</label>
                </div>
            </div>

            <div class="panel">
                <h3>🎯 Настройки по умолчанию</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="autoSave" checked>
                    <label for="autoSave">Автосохранение проекта каждые 5 минут</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="autoBackup">
                    <label for="autoBackup">Создавать резервные копии проекта</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showNotifications" checked>
                    <label for="showNotifications">Показывать уведомления о завершении</label>
                </div>
            </div>

            <div class="btn-group">
                <button class="btn btn-primary" onclick="saveSettings()">💾 Сохранить настройки</button>
                <button class="btn btn-secondary" onclick="resetSettings()">🔄 Сбросить</button>
                <button class="btn btn-secondary" onclick="exportSettings()">📤 Экспорт</button>
                <button class="btn btn-secondary" onclick="importSettings()">📥 Импорт</button>
            </div>

            <div class="panel" style="margin-top: 30px;">
                <h3>ℹ️ О программе</h3>
                <div class="info-text">
                    <strong>Auto Montage Builder Pro - Complete Edition</strong><br>
                    Версия: 4.0.0<br>
                    Оптимизировано для Adobe Premiere Pro 2020+<br><br>
                    
                    <strong>Возможности:</strong><br>
                    • Автоматическая расстановка файлов на таймлайне<br>
                    • Поддержка видео файлов с зацикливанием<br>
                    • Система каналов для YouTube<br>
                    • Ken Burns эффекты с защитой от черных полос<br>
                    • CapCut-style анимации<br>
                    • Видео и изображения оверлеи<br>
                    • Настраиваемые переходы<br>
                    • Обработка аудио с эффектами<br>
                    • 3D эффекты (базовые и продвинутые)<br>
                    • Автоматическая обработка русских путей<br><br>
                    
                    <strong>Поддержка:</strong> automontage@support.com
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно создания канала -->
    <div class="modal" id="channelModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Создание нового канала</h2>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Название канала:</label>
                    <input type="text" id="newChannelName" placeholder="Например: Мой основной канал">
                </div>
                <div class="form-group">
                    <label>Описание:</label>
                    <input type="text" id="newChannelDescription" placeholder="Краткое описание канала">
                </div>
                <div class="form-group">
                    <label>Базовый шаблон:</label>
                    <select id="newChannelTemplate">
                        <option value="youtube">YouTube (горизонтальное)</option>
                        <option value="shorts">Shorts/Reels (вертикальное)</option>
                        <option value="square">Instagram (квадрат)</option>
                        <option value="custom">Пользовательский</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('channelModal')">Отмена</button>
                <button class="btn btn-primary" onclick="saveNewChannel()">Создать</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно выбора шаблона -->
    <div class="modal" id="templateModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Выберите шаблон канала</h2>
            </div>
            <div class="modal-body">
                <div class="channel-list">
                    <div class="channel-card" onclick="createFromTemplate('dynamic')">
                        <div class="channel-name">🎬 Динамичный</div>
                        <div class="channel-info">Много движения, быстрые переходы, эффекты CapCut</div>
                    </div>
                    <div class="channel-card" onclick="createFromTemplate('cinematic')">
                        <div class="channel-name">🎥 Кинематографичный</div>
                        <div class="channel-info">Плавные движения, цветокоррекция, виньетка</div>
                    </div>
                    <div class="channel-card" onclick="createFromTemplate('minimal')">
                        <div class="channel-name">⚪ Минималистичный</div>
                        <div class="channel-info">Простые переходы, без лишних эффектов</div>
                    </div>
                    <div class="channel-card" onclick="createFromTemplate('retro')">
                        <div class="channel-name">📼 Ретро</div>
                        <div class="channel-info">Винтажные фильтры, зерно, старая пленка</div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('templateModal')">Отмена</button>
            </div>
        </div>
    </div>

    <!-- Кнопка отмены -->
    <button class="cancel-button" id="cancelButton" onclick="cancelGeneration()">✕</button>

    <script>
        // Глобальные переменные
        let PROJECT_FOLDER = null;
        let AUDIO_VARIANTS_FOLDER = null;
        let RENDERS_FOLDER = null;
        let OVERLAYS_FOLDER = null;
        let channels = [];
        let selectedChannels = new Set();
        let currentChannelId = null;
        let isGenerating = false;
        let generationAborted = false;
        let overlayFiles = [];

        // Инициализация
        document.addEventListener('DOMContentLoaded', function() {
            initializeTabs();
            loadChannels();
            loadSettings();
            setupEventListeners();
            checkEnvironment();
        });

        // Проверка окружения
        function checkEnvironment() {
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                log('CEP интерфейс инициализирован', 'info');
                
                // Проверяем версию Premiere
                csInterface.evalScript('app.version', function(version) {
                    if (version && version !== 'undefined') {
                        log(`Adobe Premiere Pro ${version}`, 'info');
                    }
                });
            } else {
                log('Работа в режиме предпросмотра (браузер)', 'warning');
            }
        }

        // Управление вкладками
        function initializeTabs() {
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetTab = tab.dataset.tab;
                    
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(targetTab).classList.add('active');
                });
            });
        }

        // Настройка слушателей событий
        function setupEventListeners() {
            // Слайдеры
            document.querySelectorAll('.slider').forEach(slider => {
                slider.addEventListener('input', function() {
                    const valueSpan = document.getElementById(this.id + 'Value');
                    if (valueSpan) {
                        let value = this.value;
                        if (this.id.includes('Angle')) {
                            value += '°';
                        } else if (this.id !== 'renderThreads' && !this.id.includes('bezier')) {
                            value += '%';
                        }
                        valueSpan.textContent = value;
                    }
                });
            });

            // Чекбоксы цветокоррекции
            document.getElementById('enableColorCorrection').addEventListener('change', function() {
                document.getElementById('colorCorrectionSettings').style.display = 
                    this.checked ? 'block' : 'none';
            });

            document.getElementById('enableVignette').addEventListener('change', function() {
                document.getElementById('vignetteSettings').style.display = 
                    this.checked ? 'block' : 'none';
            });

            document.getElementById('enableGrain').addEventListener('change', function() {
                document.getElementById('grainSettings').style.display = 
                    this.checked ? 'block' : 'none';
            });

            // 3D настройки
            document.getElementById('enable3D').addEventListener('change', function() {
                document.getElementById('3dSettings').style.display = 
                    this.checked ? 'block' : 'none';
            });

            // Интерполяция
            document.getElementById('easingType').addEventListener('change', function() {
                document.getElementById('bezierSettings').style.display = 
                    this.value === 'bezier' ? 'block' : 'none';
            });

            // Частота эффектов
            document.getElementById('effectFrequency').addEventListener('change', function() {
                document.getElementById('percentSettings').style.display = 'none';
                document.getElementById('everySettings').style.display = 'none';
                
                if (this.value === 'percent') {
                    document.getElementById('percentSettings').style.display = 'block';
                } else if (this.value === 'every') {
                    document.getElementById('everySettings').style.display = 'block';
                }
            });

            // Разрешение
            document.getElementById('channelResolution').addEventListener('change', function() {
                document.getElementById('customResolution').style.display = 
                    this.value === 'custom' ? 'block' : 'none';
            });
        }

        // Логирование
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type} slide-in`;
            
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            while (logContainer.children.length > 100) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }

        // Обновление прогресса
        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        // === РАБОТА С ПАПКОЙ ПРОЕКТА ===
        
        function selectProjectFolder() {
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                
                const extScript = `
                    var folder = Folder.selectDialog("Выберите папку проекта с файлами");
                    if (folder) {
                        folder.fsName;
                    } else {
                        null;
                    }
                `;
                
                csInterface.evalScript(extScript, function(result) {
                    if (result && result !== 'null') {
                        PROJECT_FOLDER = result;
                        document.getElementById('projectPath').value = result;
                        
                        AUDIO_VARIANTS_FOLDER = PROJECT_FOLDER + "/audio_variants";
                        RENDERS_FOLDER = PROJECT_FOLDER + "/renders";
                        
                        createSubfolders();
                        scanProjectFolder();
                    }
                });
            } else {
                // Режим симуляции
                PROJECT_FOLDER = "C:/TestProject";
                document.getElementById('projectPath').value = PROJECT_FOLDER;
                AUDIO_VARIANTS_FOLDER = PROJECT_FOLDER + "/audio_variants";
                RENDERS_FOLDER = PROJECT_FOLDER + "/renders";
                
                updateProjectInfo({
                    images: 5,
                    videos: 3,
                    audio: 8,
                    pairs: 8
                });
            }
        }

        function createSubfolders() {
            if (!PROJECT_FOLDER) return;
            
            const extScript = `
                var audioVariantsDir = new Folder("${AUDIO_VARIANTS_FOLDER.replace(/\\/g, '\\\\')}");
                if (!audioVariantsDir.exists) audioVariantsDir.create();
                
                var rendersDir = new Folder("${RENDERS_FOLDER.replace(/\\/g, '\\\\')}");
                if (!rendersDir.exists) rendersDir.create();
                
                "Подпапки созданы";
            `;
            
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                csInterface.evalScript(extScript, function(result) {
                    log('Подпапки проекта созданы', 'info');
                });
            }
        }

        function scanProjectFolder() {
            if (!PROJECT_FOLDER) return;
            
            updateProgress(10, "Сканирование папки...");
            
            const includeVideos = document.getElementById('includeVideos').checked;
            
            const extScript = `
                function scanFolder(folderPath, includeVideos) {
                    try {
                        var folder = new Folder(folderPath);
                        if (!folder.exists) {
                            return {images: 0, videos: 0, audio: 0, pairs: 0, error: "Папка не существует"};
                        }
                        
                        var images = 0;
                        var videos = 0;
                        var audio = 0;
                        var pairs = [];
                        var mediaFiles = {};
                        var audioFiles = {};
                        
                        var files = folder.getFiles();
                        var supportedImageFormats = ['.jpg', '.jpeg', '.png', '.tiff', '.bmp', '.tif'];
                        var supportedVideoFormats = ['.mp4', '.mov', '.avi', '.mkv'];
                        var supportedAudioFormats = ['.mp3', '.wav', '.aiff', '.m4a', '.flac'];
                        
                        // Сканируем файлы
                        for (var i = 0; i < files.length; i++) {
                            if (files[i] instanceof File) {
                                var fileName = files[i].name;
                                var ext = fileName.substr(fileName.lastIndexOf('.')).toLowerCase();
                                var baseNumber = fileName.match(/^(\\d{4})/);
                                
                                if (supportedImageFormats.indexOf(ext) > -1) {
                                    images++;
                                    if (baseNumber) mediaFiles[baseNumber[1]] = {type: 'image', file: files[i]};
                                } else if (includeVideos && supportedVideoFormats.indexOf(ext) > -1) {
                                    videos++;
                                    if (baseNumber) mediaFiles[baseNumber[1]] = {type: 'video', file: files[i]};
                                } else if (supportedAudioFormats.indexOf(ext) > -1) {
                                    audio++;
                                    if (baseNumber) audioFiles[baseNumber[1]] = files[i];
                                }
                            }
                        }
                        
                        // Считаем пары
                        for (var num in mediaFiles) {
                            if (audioFiles[num]) {
                                pairs.push({
                                    number: num,
                                    mediaType: mediaFiles[num].type,
                                    mediaFile: mediaFiles[num].file,
                                    audioFile: audioFiles[num]
                                });
                            }
                        }
                        
                        // Сортируем по номеру
                        pairs.sort(function(a, b) {
                            return parseInt(a.number) - parseInt(b.number);
                        });
                        
                        return {
                            images: images,
                            videos: videos,
                            audio: audio,
                            pairs: pairs
                        };
                        
                    } catch(e) {
                        return {images: 0, videos: 0, audio: 0, pairs: 0, error: e.toString()};
                    }
                }
                
                JSON.stringify(scanFolder("${PROJECT_FOLDER.replace(/\\/g, '\\\\')}", ${includeVideos}));
            `;
            
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                csInterface.evalScript(extScript, function(result) {
                    try {
                        const scanResult = JSON.parse(result);
                        updateProgress(0, "Готов к работе");
                        updateProjectInfo(scanResult);
                        
                        // Сохраняем результат для использования при генерации
                        window.lastScanResult = scanResult;
                    } catch(e) {
                        log('Ошибка сканирования: ' + e.message, 'error');
                    }
                });
            }
        }

        function updateProjectInfo(scanResult) {
            let info = "📊 Результаты сканирования:\n\n";
            info += `✅ Изображений: ${scanResult.images}\n`;
            if (scanResult.videos > 0) {
                info += `🎥 Видео: ${scanResult.videos}\n`;
            }
            info += `🎵 Аудио файлов: ${scanResult.audio}\n`;
            info += `📎 Готовых пар: ${scanResult.pairs ? scanResult.pairs.length : scanResult.pairs}`;
            
            if (scanResult.error) {
                info += `\n\n⚠️ Ошибка: ${scanResult.error}`;
            }
            
            document.getElementById('projectInfo').textContent = info;
            log(`Найдено пар файлов: ${scanResult.pairs ? scanResult.pairs.length : scanResult.pairs}`, 'info');
        }

        // === РАБОТА С КАНАЛАМИ ===

        function loadChannels() {
            const stored = localStorage.getItem('autoMontageChannels');
            if (stored) {
                try {
                    channels = JSON.parse(stored);
                } catch(e) {
                    channels = getDefaultChannels();
                }
            } else {
                channels = getDefaultChannels();
            }
            
            updateChannelLists();
        }

        function getDefaultChannels() {
            return [
                {
                    id: 'channel_' + Date.now(),
                    name: 'Основной канал',
                    description: 'Главный YouTube канал',
                    template: 'youtube',
                    export: {
                        resolution: '1920x1080',
                        customWidth: 1920,
                        customHeight: 1080,
                        fps: 30,
                        bitrate: 8,
                        codec: 'h264'
                    },
                    effects: {
                        // Ken Burns
                        kenBurns: ['zoomIn', 'panRight'],
                        kenBurnsIntensity: 30,
                        rotationAngle: 5,
                        smartCrop: true,
                        kbRandomize: false,
                        
                        // Переходы
                        transitions: ['fade', 'dissolve'],
                        transitionDuration: 1.0,
                        transRandomize: false,
                        
                        // Цветокоррекция
                        colorCorrection: true,
                        colorFilter: 'warm',
                        vignette: true,
                        vignetteIntensity: 40,
                        grain: false,
                        grainIntensity: 20,
                        
                        // Аудио
                        audioPitch: '-0.5',
                        audioEffect: 'bass',
                        audioStereoEnhance: true,
                        audioNormalize: true,
                        
                        // Анимация
                        easingType: 'ease',
                        bezierP1: 25,
                        bezierP2: 75,
                        
                        // 3D
                        enable3D: false,
                        type3D: 'basic',
                        intensity3D: 20,
                        autoRotate3D: false,
                        
                        // CapCut эффекты
                        capcutEffects: ['zoomBurst'],
                        scaleAmplitude: 15,
                        zoomBurstStart: 150,
                        zoomBurstDecay: 80,
                        motionEffects: [],
                        motionIntensity: 30,
                        effectFrequency: 'percent',
                        effectPercent: 30,
                        effectEvery: 3,
                        avoidRepetition: true
                    },
                    overlays: {
                        enabled: false,
                        files: [],
                        blendMode: 'screen',
                        opacity: 100,
                        randomize: false,
                        stretch: true
                    }
                }
            ];
        }

        function saveChannels() {
            localStorage.setItem('autoMontageChannels', JSON.stringify(channels));
        }

        function updateChannelLists() {
            // Обновляем список каналов на вкладке управления
            const channelList = document.getElementById('channelList');
            channelList.innerHTML = '';
            
            channels.forEach(channel => {
                const card = document.createElement('div');
                card.className = 'channel-card';
                card.innerHTML = `
                    <div class="channel-name">${channel.name}</div>
                    <div class="channel-info">${channel.description || 'Без описания'}</div>
                    <div class="channel-info">${channel.export.resolution} • ${channel.export.fps}fps • ${channel.export.bitrate}Mbps</div>
                    <div class="channel-actions">
                        <button class="channel-action-btn" onclick="editChannel('${channel.id}')" title="Редактировать">✏️</button>
                        <button class="channel-action-btn" onclick="duplicateChannel('${channel.id}')" title="Дублировать">📋</button>
                        <button class="channel-action-btn" onclick="deleteChannel('${channel.id}')" title="Удалить">🗑️</button>
                    </div>
                `;
                channelList.appendChild(card);
            });
            
            // Обновляем список для генерации
            const genChannelList = document.getElementById('generationChannelList');
            genChannelList.innerHTML = '';
            
            channels.forEach(channel => {
                const card = document.createElement('div');
                card.className = 'channel-card';
                card.onclick = () => toggleChannelSelection(channel.id);
                card.innerHTML = `
                    <div class="channel-name">${channel.name}</div>
                    <div class="channel-info">${channel.export.resolution} • ${channel.export.codec}</div>
                    <div class="tags-container">
                        ${channel.effects.kenBurns.length > 0 ? '<span class="tag">Ken Burns</span>' : ''}
                        ${channel.effects.capcutEffects && channel.effects.capcutEffects.length > 0 ? '<span class="tag">CapCut FX</span>' : ''}
                        ${channel.overlays && channel.overlays.enabled ? '<span class="tag">Оверлеи</span>' : ''}
                        ${channel.effects.enable3D ? '<span class="tag">3D</span>' : ''}
                    </div>
                `;
                if (selectedChannels.has(channel.id)) {
                    card.classList.add('selected');
                }
                genChannelList.appendChild(card);
            });
            
            // Обновляем селекторы
            updateChannelSelectors();
        }

        function updateChannelSelectors() {
            const selectors = [
                'channelSelector',
                'overlayChannelSelector', 
                'capcutChannelSelector'
            ];
            
            selectors.forEach(selectorId => {
                const selector = document.getElementById(selectorId);
                if (selector) {
                    const currentValue = selector.value;
                    selector.innerHTML = '<option value="">Выберите канал...</option>';
                    
                    channels.forEach(channel => {
                        const option = document.createElement('option');
                        option.value = channel.id;
                        option.textContent = channel.name;
                        selector.appendChild(option);
                    });
                    
                    selector.value = currentValue;
                }
            });
        }

        function toggleChannelSelection(channelId) {
            if (selectedChannels.has(channelId)) {
                selectedChannels.delete(channelId);
            } else {
                selectedChannels.add(channelId);
            }
            updateChannelLists();
        }

        function selectAllChannels() {
            channels.forEach(channel => selectedChannels.add(channel.id));
            updateChannelLists();
        }

        function deselectAllChannels() {
            selectedChannels.clear();
            updateChannelLists();
        }

        // === СОЗДАНИЕ И УПРАВЛЕНИЕ КАНАЛАМИ ===

        function createChannel() {
            document.getElementById('channelModal').classList.add('show');
        }

        function saveNewChannel() {
            const name = document.getElementById('newChannelName').value.trim();
            const description = document.getElementById('newChannelDescription').value.trim();
            const template = document.getElementById('newChannelTemplate').value;
            
            if (!name) {
                alert('Введите название канала!');
                return;
            }
            
            // Базовые настройки в зависимости от шаблона
            const templateSettings = {
                youtube: { resolution: '1920x1080', fps: 30, bitrate: 8 },
                shorts: { resolution: '1080x1920', fps: 30, bitrate: 10 },
                square: { resolution: '1080x1080', fps: 30, bitrate: 6 },
                custom: { resolution: 'custom', fps: 30, bitrate: 8 }
            };
            
            const settings = templateSettings[template] || templateSettings.youtube;
            
            const newChannel = {
                id: 'channel_' + Date.now(),
                name: name,
                description: description,
                template: template,
                export: {
                    resolution: settings.resolution,
                    customWidth: 1920,
                    customHeight: 1080,
                    fps: settings.fps,
                    bitrate: settings.bitrate,
                    codec: 'h264'
                },
                effects: {
                    kenBurns: [],
                    kenBurnsIntensity: 30,
                    rotationAngle: 5,
                    smartCrop: true,
                    kbRandomize: false,
                    transitions: ['fade'],
                    transitionDuration: 1.0,
                    transRandomize: false,
                    colorCorrection: false,
                    colorFilter: 'none',
                    vignette: false,
                    vignetteIntensity: 40,
                    grain: false,
                    grainIntensity: 20,
                    audioPitch: '0',
                    audioEffect: 'none',
                    audioStereoEnhance: false,
                    audioNormalize: true,
                    easingType: 'ease',
                    bezierP1: 25,
                    bezierP2: 75,
                    enable3D: false,
                    type3D: 'basic',
                    intensity3D: 20,
                    autoRotate3D: false,
                    capcutEffects: [],
                    scaleAmplitude: 15,
                    zoomBurstStart: 150,
                    zoomBurstDecay: 80,
                    motionEffects: [],
                    motionIntensity: 30,
                    effectFrequency: 'all',
                    effectPercent: 50,
                    effectEvery: 3,
                    avoidRepetition: true
                },
                overlays: {
                    enabled: false,
                    files: [],
                    blendMode: 'screen',
                    opacity: 100,
                    randomize: false,
                    stretch: true
                }
            };
            
            channels.push(newChannel);
            saveChannels();
            updateChannelLists();
            closeModal('channelModal');
            log(`Создан новый канал: ${name}`, 'info');
        }

        function createChannelFromTemplate() {
            document.getElementById('templateModal').classList.add('show');
        }

        function createFromTemplate(templateType) {
            const templates = {
                dynamic: {
                    name: 'Динамичный канал',
                    description: 'Много движения и эффектов',
                    kenBurns: ['zoomIn', 'zoomOut', 'panLeft', 'panRight', 'rotate'],
                    kenBurnsIntensity: 50,
                    transitions: ['zoom', 'slide', 'push'],
                    transitionD<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto Montage Builder Pro - Complete Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }

        body {
            background: #0f0f23;
            color: #ffffff;
            padding: 0;
            overflow-x: hidden;
            min-height: 100vh;
            min-width: 900px;
            display: flex;
            flex-direction: column;
        }

        .container {
            width: 100%;
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 900px;
        }

        .header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
            color: #4CAF50;
            text-align: center;
            margin: 0;
        }

        .tabs-container {
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .tabs {
            display: flex;
            padding: 0;
            margin: 0;
            min-width: 900px;
        }

        .tab {
            flex: 1;
            min-width: 120px;
            padding: 12px 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
            border: none;
            background: transparent;
            color: #ffffff;
            opacity: 0.7;
            position: relative;
            white-space: nowrap;
        }

        .tab:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.05);
        }

        .tab.active {
            opacity: 1;
            background: rgba(76, 175, 80, 0.1);
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #4CAF50;
        }

        .tab-content {
            display: none;
            padding: 20px;
            flex: 1;
            overflow-y: auto;
            animation: fadeIn 0.3s ease;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel h3 {
            margin-bottom: 15px;
            color: #4CAF50;
            font-size: 16px;
            font-weight: 500;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #cccccc;
        }

        .form-row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .form-row label {
            margin-bottom: 0;
            min-width: 140px;
            font-size: 13px;
        }

        input[type="text"], 
        input[type="number"], 
        select {
            flex: 1;
            min-width: 150px;
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            font-size: 13px;
        }

        select {
            cursor: pointer;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 16px;
            padding-right: 35px;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }

        select option {
            background: #1a1a2e;
            color: #ffffff;
            padding: 10px;
        }

        input[type="text"]:focus, 
        input[type="number"]:focus, 
        select:focus {
            outline: none;
            border-color: #4CAF50;
            background: rgba(255, 255, 255, 0.15);
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #d32f2f;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .progress-container {
            margin-top: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #81C784);
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: 500;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            z-index: 1;
        }

        .info-panel {
            background: rgba(33, 150, 243, 0.1);
            border: 1px solid rgba(33, 150, 243, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .info-text {
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-line;
        }

        .warning-panel {
            background: rgba(255, 152, 0, 0.1);
            border: 1px solid rgba(255, 152, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        /* Каналы */
        .channel-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .channel-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .channel-card:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(76, 175, 80, 0.5);
            transform: translateY(-2px);
        }

        .channel-card.selected {
            background: rgba(76, 175, 80, 0.2);
            border-color: #4CAF50;
        }

        .channel-name {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 5px;
        }

        .channel-info {
            font-size: 11px;
            color: #999;
            margin-bottom: 3px;
        }

        .channel-actions {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
        }

        .channel-action-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .channel-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Эффекты двухколоночные */
        .effects-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1200px) {
            .effects-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Чекбоксы и радио */
        .checkbox-group,
        .radio-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        input[type="checkbox"],
        input[type="radio"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #4CAF50;
        }

        /* Слайдеры */
        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .slider-group label {
            min-width: 140px;
            margin-bottom: 0;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb:hover {
            background: #81C784;
            transform: scale(1.2);
        }

        .slider-value {
            min-width: 50px;
            text-align: center;
            font-size: 12px;
            color: #4CAF50;
            font-weight: 500;
        }

        /* Логи */
        .log-container {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            height: 150px;
            overflow-y: auto;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 2px;
            padding: 2px 0;
        }

        .log-info { color: #4CAF50; }
        .log-warning { color: #ff9800; }
        .log-error { color: #f44336; }

        /* Список эффектов с чекбоксами */
        .effects-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .effect-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            transition: all 0.2s;
        }

        .effect-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .effect-item input:checked + label {
            color: #4CAF50;
        }

        /* Модальное окно */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #1a1a2e;
            border-radius: 8px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            margin-bottom: 20px;
        }

        .modal-header h2 {
            color: #4CAF50;
            font-size: 20px;
            margin: 0;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* Скроллбары */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(76, 175, 80, 0.6);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(76, 175, 80, 0.8);
        }

        /* Плавающая кнопка отмены */
        .cancel-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 56px;
            height: 56px;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 999;
            transition: all 0.3s ease;
        }

        .cancel-button.show {
            display: flex;
        }

        .cancel-button:hover {
            background: #d32f2f;
            transform: scale(1.1);
        }

        /* Теги для эффектов */
        .tag {
            display: inline-block;
            padding: 4px 12px;
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
            border-radius: 16px;
            font-size: 11px;
            margin: 2px;
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        /* Секции настроек */
        .settings-section {
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings-section:last-child {
            border-bottom: none;
        }

        .settings-section h4 {
            color: #81C784;
            font-size: 14px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Колонки эффектов */
        .effects-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1000px) {
            .effects-columns {
                grid-template-columns: 1fr;
            }
        }

        /* Подсказки */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .tooltip::after {
            content: attr(data-tip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            margin-bottom: 5px;
        }

        .tooltip:hover::after {
            opacity: 1;
        }

        /* Индикаторы загрузки */
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #4CAF50;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Компактный режим для маленьких экранов */
        @media (max-width: 1200px) {
            .container {
                min-width: 800px;
            }
            
            .tabs {
                min-width: 800px;
            }
            
            .channel-list {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }
        }

        /* Стиль для разделителей */
        .divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: 20px 0;
        }

        /* Цветные индикаторы для эффектов */
        .effect-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }

        .effect-indicator.active {
            background: #4CAF50;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
        }

        .effect-indicator.inactive {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Панель быстрых настроек */
        .quick-settings {
            display: flex;
            gap: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .quick-setting-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Стили для файловых путей */
        .file-path {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 12px;
            word-break: break-all;
        }

        .file-path-icon {
            font-size: 16px;
        }

        /* Анимация для новых элементов */
        @keyframes slideInLeft {
            from {
                transform: translateX(-20px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .slide-in {
            animation: slideInLeft 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎬 AUTO MONTAGE BUILDER PRO - COMPLETE EDITION</h1>
        </div>

        <div class="tabs-container">
            <div class="tabs">
                <button class="tab active" data-tab="generation">🎬 Генерация</button>
                <button class="tab" data-tab="channels">📺 Каналы</button>
                <button class="tab" data-tab="effects">🎨 Эффекты</button>
                <button class="tab" data-tab="overlays">🎭 Оверлеи</button>
                <button class="tab" data-tab="capcut">✨ CapCut FX</button>
                <button class="tab" data-tab="settings">⚙️ Настройки</button>
            </div>
        </div>

        <!-- Вкладка Генерация -->
        <div class="tab-content active" id="generation">
            <div class="panel">
                <h3>📁 Папка проекта</h3>
                <div class="form-row">
                    <input type="text" id="projectPath" placeholder="Выберите папку с файлами (изображения/видео + аудио)" readonly>
                    <button class="btn btn-secondary" onclick="selectProjectFolder()">Обзор...</button>
                </div>
                <div class="checkbox-group" style="margin-top: 10px;">
                    <input type="checkbox" id="includeVideos" checked>
                    <label for="includeVideos">Включить видео файлы (MP4, MOV, AVI)</label>
                </div>
            </div>

            <div class="info-panel">
                <div class="info-text" id="projectInfo">Выберите папку проекта для начала работы.
Поддерживаются форматы:
• Изображения: JPG, PNG, TIFF, BMP
• Видео: MP4, MOV, AVI, MKV
• Аудио: MP3, WAV, M4A, FLAC</div>
            </div>

            <div class="panel">
                <h3>📺 Выбор каналов для генерации</h3>
                <div class="channel-list" id="generationChannelList">
                    <!-- Динамически генерируется -->
                </div>
                <div class="quick-settings">
                    <button class="btn btn-small btn-secondary" onclick="selectAllChannels()">Выбрать все</button>
                    <button class="btn btn-small btn-secondary" onclick="deselectAllChannels()">Снять выделение</button>
                </div>
            </div>

            <div class="panel">
                <h3>🎵 Подготовка аудио</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="processAudioFirst" checked>
                    <label for="processAudioFirst">Автоматически обработать аудио перед генерацией</label>
                </div>
                <div class="info-text" style="font-size: 12px; color: #999; margin-top: 10px;">
                    Для каждого канала будут созданы уникальные аудио файлы с заданными настройками тональности и эффектов
                </div>
            </div>

            <div class="btn-group">
                <button class="btn btn-secondary" onclick="testMontage()">🧪 Тест (1 пара)</button>
                <button class="btn btn-secondary" onclick="importFiles()">📂 Импорт в проект</button>
                <button class="btn btn-primary" onclick="generateMontage()" id="generateBtn">
                    🎬 СОЗДАТЬ МОНТАЖ
                </button>
            </div>

            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                    <div class="progress-text" id="progressText">Готов к работе</div>
                </div>
            </div>

            <div class="log-container" id="logContainer">
                <div class="log-entry log-info">Система готова к работе</div>
                <div class="log-entry log-info">Минимальные требования: Adobe Premiere Pro 2020+</div>
            </div>
        </div>

        <!-- Вкладка Каналы -->
        <div class="tab-content" id="channels">
            <div class="panel">
                <h3>📺 Управление каналами</h3>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="createChannel()">➕ Создать канал</button>
                    <button class="btn btn-secondary" onclick="importChannels()">📥 Импорт</button>
                    <button class="btn btn-secondary" onclick="exportChannels()">📤 Экспорт</button>
                    <button class="btn btn-secondary" onclick="createChannelFromTemplate()">📋 Из шаблона</button>
                </div>
            </div>

            <div class="panel">
                <h3>📋 Список каналов</h3>
                <div class="channel-list" id="channelList">
                    <!-- Динамически генерируется -->
                </div>
            </div>
        </div>

        <!-- Вкладка Эффекты -->
        <div class="tab-content" id="effects">
            <div class="panel">
                <h3>📺 Редактирование канала</h3>
                <select id="channelSelector" onchange="loadChannelEffects()">
                    <option value="">Выберите канал...</option>
                </select>
            </div>

            <div id="effectsEditor" style="display: none;">
                <div class="effects-columns">
                    <!-- Левая колонка -->
                    <div>
                        <!-- Настройки экспорта -->
                        <div class="panel">
                            <h3>📤 Настройки экспорта</h3>
                            <div class="form-row">
                                <label>Разрешение:</label>
                                <select id="channelResolution">
                                    <option value="1920x1080">1920×1080 (Full HD)</option>
                                    <option value="3840x2160">3840×2160 (4K)</option>
                                    <option value="1280x720">1280×720 (HD)</option>
                                    <option value="1080x1920">1080×1920 (Вертикальное)</option>
                                    <option value="1080x1080">1080×1080 (Квадрат)</option>
                                    <option value="custom">Пользовательское</option>
                                </select>
                            </div>
                            
                            <div id="customResolution" style="display: none;">
                                <div class="form-row">
                                    <label>Ширина:</label>
                                    <input type="number" id="customWidth" value="1920" min="320" max="7680">
                                    <label>Высота:</label>
                                    <input type="number" id="customHeight" value="1080" min="240" max="4320">
                                </div>
                            </div>
                            
                            <div class="form-row">
                                <label>FPS:</label>
                                <select id="channelFps">
                                    <option value="24">24</option>
                                    <option value="25">25</option>
                                    <option value="30" selected>30</option>
                                    <option value="50">50</option>
                                    <option value="60">60</option>
                                </select>
                            </div>
                            
                            <div class="form-row">
                                <label>Битрейт (Mbps):</label>
                                <input type="number" id="channelBitrate" value="8" min="1" max="100">
                            </div>
                            
                            <div class="form-row">
                                <label>Кодек:</label>
                                <select id="channelCodec">
                                    <option value="h264">H.264</option>
                                    <option value="h265">H.265/HEVC</option>
                                    <option value="prores">ProRes</option>
                                </select>
                            </div>
                        </div>

                        <!-- Ken Burns эффекты -->
                        <div class="panel">
                            <h3>🎬 Ken Burns эффекты</h3>
                            <div class="effects-list">
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_zoomIn" class="kb-effect">
                                    <label for="kb_zoomIn">Zoom In (приближение)</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_zoomOut" class="kb-effect">
                                    <label for="kb_zoomOut">Zoom Out (отдаление)</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_panLeft" class="kb-effect">
                                    <label for="kb_panLeft">Pan Left (влево)</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_panRight" class="kb-effect">
                                    <label for="kb_panRight">Pan Right (вправо)</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_panUp" class="kb-effect">
                                    <label for="kb_panUp">Pan Up (вверх)</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_panDown" class="kb-effect">
                                    <label for="kb_panDown">Pan Down (вниз)</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_rotate" class="kb-effect">
                                    <label for="kb_rotate">Rotate (вращение)</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_diagonal" class="kb-effect">
                                    <label for="kb_diagonal">Diagonal (диагональ)</label>
                                </div>
                            </div>
                            
                            <div class="slider-group">
                                <label>Интенсивность:</label>
                                <input type="range" id="kbIntensity" class="slider" min="0" max="100" value="30">
                                <span class="slider-value" id="kbIntensityValue">30%</span>
                            </div>
                            
                            <div class="slider-group">
                                <label>Угол вращения:</label>
                                <input type="range" id="rotationAngle" class="slider" min="0" max="45" value="5">
                                <span class="slider-value" id="rotationAngleValue">5°</span>
                            </div>
                            
                            <div class="checkbox-group">
                                <input type="checkbox" id="kbSmartCrop" checked>
                                <label for="kbSmartCrop">Умная обрезка (без черных полос)</label>
                            </div>
                            
                            <div class="checkbox-group">
                                <input type="checkbox" id="kbRandomize">
                                <label for="kbRandomize">Рандомизировать направление для каждого клипа</label>
                            </div>
                        </div>

                        <!-- Аудио настройки -->
                        <div class="panel">
                            <h3>🎵 Аудио настройки</h3>
                            <div class="form-row">
                                <label>Тональность:</label>
                                <select id="audioPitch">
                                    <option value="-3">-3 (очень низкий)</option>
                                    <option value="-2">-2 (низкий)</option>
                                    <option value="-1.5">-1.5</option>
                                    <option value="-1">-1</option>
                                    <option value="-0.5">-0.5</option>
                                    <option value="0" selected>0 (оригинал)</option>
                                    <option value="+0.5">+0.5</option>
                                    <option value="+1">+1</option>
                                    <option value="+1.5">+1.5</option>
                                    <option value="+2">+2 (высокий)</option>
                                    <option value="+3">+3 (очень высокий)</option>
                                </select>
                            </div>
                            
                            <div class="form-row">
                                <label>Эффект:</label>
                                <select id="audioEffect">
                                    <option value="none">Без эффекта</option>
                                    <option value="bass">Усиление басов</option>
                                    <option value="reverb">Реверберация</option>
                                    <option value="echo">Эхо</option>
                                    <option value="chorus">Хорус</option>
                                    <option value="telephone">Телефон</option>
                                    <option value="underwater">Под водой</option>
                                    <option value="radio">Радио</option>
                                    <option value="vintage">Винтаж</option>
                                </select>
                            </div>
                            
                            <div class="checkbox-group">
                                <input type="checkbox" id="audioStereoEnhance">
                                <label for="audioStereoEnhance">Расширение стерео</label>
                            </div>
                            
                            <div class="checkbox-group">
                                <input type="checkbox" id="audioNormalize" checked>
                                <label for="audioNormalize">Нормализация громкости</label>
                            </div>
                        </div>
                    </div>

                    <!-- Правая колонка -->
                    <div>
                        <!-- Переходы -->
                        <div class="panel">
                            <h3>🔄 Переходы</h3>
                            <div class="effects-list">
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_fade" class="transition-effect">
                                    <label for="trans_fade">Fade</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_dissolve" class="transition-effect">
                                    <label for="trans_dissolve">Cross Dissolve</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_dip_black" class="transition-effect">
                                    <label for="trans_dip_black">Dip to Black</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_dip_white" class="transition-effect">
                                    <label for="trans_dip_white">Dip to White</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_wipe" class="transition-effect">
                                    <label for="trans_wipe">Wipe</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_slide" class="transition-effect">
                                    <label for="trans_slide">Slide</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_push" class="transition-effect">
                                    <label for="trans_push">Push</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_zoom" class="transition-effect">
                                    <label for="trans_zoom">Zoom</label>
                                </div>
                            </div>
                            
                            <div class="form-row">
                                <label>Длительность:</label>
                                <input type="number" id="transitionDuration" value="1.0" min="0.1" max="3.0" step="0.1">
                                <span>секунд</span>
                            </div>
                            
                            <div class="checkbox-group">
                                <input type="checkbox" id="transRandomize">
                                <label for="transRandomize">Случайный выбор переходов</label>
                            </div>
                        </div>

                        <!-- Цветокоррекция -->
                        <div class="panel">
                            <h3>🎨 Цветокоррекция</h3>
                            <div class="checkbox-group">
                                <input type="checkbox" id="enableColorCorrection">
                                <label for="enableColorCorrection">Включить цветокоррекцию</label>
                            </div>
                            
                            <div id="colorCorrectionSettings" style="display: none;">
                                <div class="form-row">
                                    <label>Фильтр:</label>
                                    <select id="colorFilter">
                                        <option value="none">Без фильтра</option>
                                        <option value="warm">Теплый</option>
                                        <option value="cold">Холодный</option>
                                        <option value="vintage">Винтаж</option>
                                        <option value="blackwhite">Черно-белый</option>
                                        <option value="sepia">Сепия</option>
                                        <option value="cinematic">Кинематографичный</option>
                                        <option value="vibrant">Насыщенный</option>
                                        <option value="faded">Выцветший</option>
                                    </select>
                                </div>
                                
                                <div class="checkbox-group">
                                    <input type="checkbox" id="enableVignette">
                                    <label for="enableVignette">Виньетка</label>
                                </div>
                                
                                <div class="slider-group" id="vignetteSettings" style="display: none;">
                                    <label>Интенсивность:</label>
                                    <input type="range" id="vignetteIntensity" class="slider" min="0" max="100" value="40">
                                    <span class="slider-value" id="vignetteIntensityValue">40%</span>
                                </div>
                                
                                <div class="checkbox-group">
                                    <input type="checkbox" id="enableGrain">
                                    <label for="enableGrain">Зерно пленки</label>
                                </div>
                                
                                <div class="slider-group" id="grainSettings" style="display: none;">
                                    <label>Интенсивность:</label>
                                    <input type="range" id="grainIntensity" class="slider" min="0" max="100" value="20">
                                    <span class="slider-value" id="grainIntensityValue">20%</span>
                                </div>
                            </div>
                        </div>

                        <!-- Плавность анимации -->
                        <div class="panel">
                            <h3>⚡ Плавность анимации</h3>
                            <div class="form-row">
                                <label>Тип интерполяции:</label>
                                <select id="easingType">
                                    <option value="linear">Линейная</option>
                                    <option value="ease" selected>Плавная</option>
                                    <option value="ease-in">Ускорение</option>
                                    <option value="ease-out">Замедление</option>
                                    <option value="ease-in-out">Ускорение и замедление</option>
                                    <option value="bezier">Кривая Безье</option>
                                    <option value="bounce">Отскок</option>
                                    <option value="elastic">Эластичная</option>
                                </select>
                            </div>
                            
                            <div id="bezierSettings" style="display: none;">
                                <div class="slider-group">
                                    <label>Точка 1:</label>
                                    <input type="range" id="bezierP1" class="slider" min="0" max="100" value="25">
                                    <span class="slider-value" id="bezierP1Value">25</span>
                                </div>
                                <div class="slider-group">
                                    <label>Точка 2:</label>
                                    <input type="range" id="bezierP2" class="slider" min="0" max="100" value="75">
                                    <span class="slider-value" id="bezierP2Value">75</span>
                                </div>
                            </div>
                        </div>

                        <!-- 3D эффекты -->
                        <div class="panel">
                            <h3>🎯 3D эффекты</h3>
                            <div class="checkbox-group">
                                <input type="checkbox" id="enable3D">
                                <label for="enable3D">Включить 3D движение</label>
                            </div>
                            
                            <div id="3dSettings" style="display: none;">
                                <div class="form-row">
                                    <label>Тип 3D:</label>
                                    <select id="3dType">
                                        <option value="basic">Базовый поворот</option>
                                        <option value="parallax">Параллакс (слои)</option>
                                        <option value="depth">Глубина (требует обработки)</option>
                                    </select>
                                </div>
                                
                                <div class="slider-group">
                                    <label>Интенсивность:</label>
                                    <input type="range" id="3dIntensity" class="slider" min="0" max="100" value="20">
                                    <span class="slider-value" id="3dIntensityValue">20%</span>
                                </div>
                                
                                <div class="checkbox-group">
                                    <input type="checkbox" id="3dAutoRotate">
                                    <label for="3dAutoRotate">Автовращение</label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="btn-group">
                    <button class="btn btn-primary" onclick="saveChannelEffects()">💾 Сохранить настройки</button>
                    <button class="btn btn-secondary" onclick="resetChannelEffects()">🔄 Сбросить</button>
                    <button class="btn btn-secondary" onclick="previewEffects()">👁️ Предпросмотр</button>
                    <button class="btn btn-secondary" onclick="duplicateToChannel()">📋 Копировать в...</button>
                </div>
            </div>
        </div>

        <!-- Вкладка Оверлеи -->
        <div class="tab-content" id="overlays">
            <div class="panel">
                <h3>🎭 Управление оверлеями</h3>
                <div class="form-row">
                    <label>Папка с оверлеями:</label>
                    <input type="text" id="overlaysPath" placeholder="Выберите папку с оверлеями" readonly>
                    <button class="btn btn-secondary" onclick="selectOverlaysFolder()">Обзор...</button>
                </div>
                <div class="info-text" style="margin-top: 10px; font-size: 12px;">
                    Поддерживаются: PNG (с прозрачностью), MP4, MOV, GIF
                </div>
            </div>

            <div class="panel">
                <h3>📺 Назначение оверлеев каналам</h3>
                <select id="overlayChannelSelector" onchange="loadChannelOverlays()">
                    <option value="">Выберите канал...</option>
                </select>
                
                <div id="overlaySettings" style="display: none; margin-top: 20px;">
                    <div class="panel">
                        <h3>Доступные оверлеи</h3>
                        <div id="overlaysList" class="effects-list">
                            <!-- Динамически заполняется -->
                        </div>
                    </div>
                    
                    <div class="panel">
                        <h3>Настройки наложения</h3>
                        <div class="form-row">
                            <label>Режим наложения:</label>
                            <select id="overlayBlendMode">
                                <option value="normal">Normal</option>
                                <option value="screen">Screen (для бликов)</option>
                                <option value="overlay">Overlay</option>
                                <option value="multiply">Multiply</option>
                                <option value="add">Add</option>
                                <option value="lighten">Lighten</option>
                                <option value="darken">Darken</option>
                            </select>
                        </div>
                        
                        <div class="slider-group">
                            <label>Прозрачность:</label>
                            <input type="range" id="overlayOpacity" class="slider" min="0" max="100" value="100">
                            <span class="slider-value" id="overlayOpacityValue">100%</span>
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="overlayRandomize">
                            <label for="overlayRandomize">Случайный выбор оверлеев</label>
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="overlayStretch" checked>
                            <label for="overlayStretch">Растягивать на весь экран</label>
                        </div>
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="saveOverlaySettings()">💾 Сохранить</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Вкладка CapCut эффекты -->
        <div class="tab-content" id="capcut">
            <div class="panel">
                <h3>✨ CapCut-style эффекты</h3>
                <select id="capcutChannelSelector" onchange="loadChannelCapcutEffects()">
                    <option value="">Выберите канал...</option>
                </select>
            </div>

            <div id="capcutEffectsEditor" style="display: none;">
                <div class="effects-columns">
                    <!-- Анимации масштаба -->
                    <div class="panel">
                        <h3>🔍 Анимации масштаба</h3>
                        <div class="effects-list">
                            <div class="effect-item">
                                <input type="checkbox" id="fx_zoomBurst" class="capcut-effect">
                                <label for="fx_zoomBurst">Zoom Burst (резкий зум)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_pulse" class="capcut-effect">
                                <label for="fx_pulse">Pulse (пульсация)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_bounce" class="capcut-effect">
                                <label for="fx_bounce">Bounce (отскок)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_elastic" class="capcut-effect">
                                <label for="fx_elastic">Elastic (эластичный)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_wave" class="capcut-effect">
                                <label for="fx_wave">Wave (волна)</label>
                            </div>
                        </div>
                        
                        <div class="slider-group">
                            <label>Амплитуда:</label>
                            <input type="range" id="scaleAmplitude" class="slider" min="0" max="50" value="15">
                            <span class="slider-value" id="scaleAmplitudeValue">15%</span>
                        </div>
                        
                        <div class="settings-section">
                            <h4>Настройки Zoom Burst</h4>
                            <div class="slider-group">
                                <label>Начальный зум:</label>
                                <input type="range" id="zoomBurstStart" class="slider" min="100" max="200" value="150">
                                <span class="slider-value" id="zoomBurstStartValue">150%</span>
                            </div>
                            <div class="slider-group">
                                <label>Скорость затухания:</label>
                                <input type="range" id="zoomBurstDecay" class="slider" min="0" max="100" value="80">
                                <span class="slider-value" id="zoomBurstDecayValue">80%</span>
                            </div>
                        </div>
                    </div>

                    <!-- Движение и тряска -->
                    <div class="panel">
                        <h3>🎯 Движение и тряска</h3>
                        <div class="effects-list">
                            <div class="effect-item">
                                <input type="checkbox" id="fx_shake" class="capcut-effect">
                                <label for="fx_shake">Shake (тряска)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_wobble" class="capcut-effect">
                                <label for="fx_wobble">Wobble (покачивание)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_pendulum" class="capcut-effect">
                                <label for="fx_pendulum">Pendulum (маятник)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_swing" class="capcut-effect">
                                <label for="fx_swing">Swing (раскачивание)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_glitch" class="capcut-effect">
                                <label for="fx_glitch">Glitch (глитч)</label>
                            </div>
                        </div>
                        
                        <div class="slider-group">
                            <label>Интенсивность:</label>
                            <input type="range" id="motionIntensity" class="slider" min="0" max="100" value="30">
                            <span class="slider-value" id="motionIntensityValue">30%</span>
                        </div>
                    </div>
                </div>

                <!-- Частота применения -->
                <div class="panel">
                    <h3>📊 Частота применения эффектов</h3>
                    <div class="form-row">
                        <label>Применять к:</label>
                        <select id="effectFrequency">
                            <option value="all">Всем клипам</option>
                            <option value="percent">Проценту клипов</option>
                            <option value="every">Каждому N-му клипу</option>
                            <option value="random">Случайно</option>
                        </select>
                    </div>
                    
                    <div id="frequencySettings">
                        <div class="slider-group" id="percentSettings" style="display: none;">
                            <label>Процент клипов:</label>
                            <input type="range" id="effectPercent" class="slider" min="0" max="100" value="50">
                            <span class="slider-value" id="effectPercentValue">50%</span>
                        </div>
                        
                        <div class="form-row" id="everySettings" style="display: none;">
                            <label>Каждый:</label>
                            <input type="number" id="effectEvery" value="3" min="2" max="10">
                            <span>клип</span>
                        </div>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="avoidRepetition" checked>
                        <label for="avoidRepetition">Избегать повторения эффектов подряд</label>
                    </div>
                </div>

                <div class="btn-group">
                    <button class="btn btn-primary" onclick="saveCapcutEffects()">💾 Сохранить</button>
                    <button class="btn btn-secondary" onclick="presetCapcutEffects('dynamic')">🎬 Пресет: Динамичный</button>
                    <button class="btn btn-secondary" onclick="presetCapcutEffects('smooth')">🌊 Пресет: Плавный</button>
                    <button class="btn btn-secondary" onclick="presetCapcutEffects('epic')">⚡ Пресет: Эпичный</button>
                </div>
            </div>
        </div>

        <!-- Вкладка Настройки -->
        <div class="tab-content" id="settings">
            <div class="panel">
                <h3>📁 Пути к программам</h3>
                <div class="form-group">
                    <label>FFmpeg:</label>
                    <div class="form-row">
                        <input type="text" id="ffmpegPath" value="ffmpeg.exe">
                        <button class="btn btn-secondary" onclick="browsePath('ffmpeg')">...</button>
                        <button class="btn btn-small btn-secondary" onclick="downloadFFmpeg()">⬇️ Скачать</button>
                    </div>
                    <div class="info-text" style="font-size: 11px; color: #999; margin-top: 5px;">
                        Используется для обработки аудио
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Media Encoder:</label>
                    <div class="form-row">
                        <input type="text" id="amePath" value="">
                        <button class="btn btn-secondary" onclick="browsePath('ame')">...</button>
                        <button class="btn btn-small btn-secondary" onclick="findMediaEncoder()">🔍 Найти</button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Python (для 3D эффектов):</label>
                    <div class="form-row">
                        <input type="text" id="pythonPath" value="python">
                        <button class="btn btn-secondary" onclick="browsePath('python')">...</button>
                        <button class="btn btn-small btn-secondary" onclick="checkPython()">✓ Проверить</button>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>⚡ Производительность</h3>
                <div class="slider-group">
                    <label>Потоки рендеринга:</label>
                    <input type="range" id="renderThreads" class="slider" min="1" max="16" value="4">
                    <span class="slider-value" id="renderThreadsValue">4</span>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="useGPU" checked>
                    <label for="useGPU">Использовать GPU ускорение</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="useProxies">
                    <label for="useProxies">Создавать прокси для 4K видео</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="preRenderEffects">
                    <label for="preRenderEffects">Предварительный рендер сложных
