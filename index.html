<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto Montage Builder Pro - Complete Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }

        body {
            background: #0f0f23;
            color: #ffffff;
            padding: 0;
            overflow-x: hidden;
            min-height: 100vh;
            min-width: 900px;
            display: flex;
            flex-direction: column;
        }

        .container {
            width: 100%;
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 900px;
        }

        .header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
            color: #4CAF50;
            text-align: center;
            margin: 0;
        }

        .tabs-container {
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .tabs {
            display: flex;
            padding: 0;
            margin: 0;
            min-width: 900px;
        }

        .tab {
            flex: 1;
            min-width: 120px;
            padding: 12px 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
            border: none;
            background: transparent;
            color: #ffffff;
            opacity: 0.7;
            position: relative;
            white-space: nowrap;
        }

        .tab:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.05);
        }

        .tab.active {
            opacity: 1;
            background: rgba(76, 175, 80, 0.1);
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #4CAF50;
        }

        .tab-content {
            display: none;
            padding: 20px;
            flex: 1;
            overflow-y: auto;
            animation: fadeIn 0.3s ease;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel h3 {
            margin-bottom: 15px;
            color: #4CAF50;
            font-size: 16px;
            font-weight: 500;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #cccccc;
        }

        .form-row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .form-row label {
            margin-bottom: 0;
            min-width: 140px;
            font-size: 13px;
        }

        input[type="text"], 
        input[type="number"], 
        select {
            flex: 1;
            min-width: 150px;
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            font-size: 13px;
        }

        select {
            cursor: pointer;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 16px;
            padding-right: 35px;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }

        select option {
            background: #1a1a2e;
            color: #ffffff;
            padding: 10px;
        }

        input[type="text"]:focus, 
        input[type="number"]:focus, 
        select:focus {
            outline: none;
            border-color: #4CAF50;
            background: rgba(255, 255, 255, 0.15);
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #d32f2f;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .progress-container {
            margin-top: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #81C784);
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: 500;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            z-index: 1;
        }

        .info-panel {
            background: rgba(33, 150, 243, 0.1);
            border: 1px solid rgba(33, 150, 243, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .info-text {
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-line;
        }

        .warning-panel {
            background: rgba(255, 152, 0, 0.1);
            border: 1px solid rgba(255, 152, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        /* Каналы */
        .channel-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .channel-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .channel-card:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(76, 175, 80, 0.5);
            transform: translateY(-2px);
        }

        .channel-card.selected {
            background: rgba(76, 175, 80, 0.2);
            border-color: #4CAF50;
        }

        .channel-name {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 5px;
        }

        .channel-info {
            font-size: 11px;
            color: #999;
            margin-bottom: 3px;
        }

        .channel-actions {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
        }

        .channel-action-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .channel-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Эффекты двухколоночные */
        .effects-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1200px) {
            .effects-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Чекбоксы и радио */
        .checkbox-group,
        .radio-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        input[type="checkbox"],
        input[type="radio"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #4CAF50;
        }

        /* Слайдеры */
        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .slider-group label {
            min-width: 140px;
            margin-bottom: 0;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb:hover {
            background: #81C784;
            transform: scale(1.2);
        }

        .slider-value {
            min-width: 50px;
            text-align: center;
            font-size: 12px;
            color: #4CAF50;
            font-weight: 500;
        }

        /* Логи */
        .log-container {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            height: 150px;
            overflow-y: auto;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 2px;
            padding: 2px 0;
        }

        .log-info { color: #4CAF50; }
        .log-warning { color: #ff9800; }
        .log-error { color: #f44336; }

        /* Список эффектов с чекбоксами */
        .effects-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .effect-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            transition: all 0.2s;
        }

        .effect-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .effect-item input:checked + label {
            color: #4CAF50;
        }

        /* Модальное окно */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #1a1a2e;
            border-radius: 8px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            margin-bottom: 20px;
        }

        .modal-header h2 {
            color: #4CAF50;
            font-size: 20px;
            margin: 0;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* Скроллбары */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(76, 175, 80, 0.6);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(76, 175, 80, 0.8);
        }

        /* Плавающая кнопка отмены */
        .cancel-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 56px;
            height: 56px;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 999;
            transition: all 0.3s ease;
        }

        .cancel-button.show {
            display: flex;
        }

        .cancel-button:hover {
            background: #d32f2f;
            transform: scale(1.1);
        }

        /* Теги для эффектов */
        .tag {
            display: inline-block;
            padding: 4px 12px;
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
            border-radius: 16px;
            font-size: 11px;
            margin: 2px;
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        /* Секции настроек */
        .settings-section {
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings-section:last-child {
            border-bottom: none;
        }

        .settings-section h4 {
            color: #81C784;
            font-size: 14px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Колонки эффектов */
        .effects-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1000px) {
            .effects-columns {
                grid-template-columns: 1fr;
            }
        }

        /* Подсказки */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .tooltip::after {
            content: attr(data-tip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            margin-bottom: 5px;
        }

        .tooltip:hover::after {
            opacity: 1;
        }

        /* Индикаторы загрузки */
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #4CAF50;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Компактный режим для маленьких экранов */
        @media (max-width: 1200px) {
            .container {
                min-width: 800px;
            }
            
            .tabs {
                min-width: 800px;
            }
            
            .channel-list {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            }
        }

        /* Стиль для разделителей */
        .divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: 20px 0;
        }

        /* Цветные индикаторы для эффектов */
        .effect-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }

        .effect-indicator.active {
            background: #4CAF50;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
        }

        .effect-indicator.inactive {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Панель быстрых настроек */
        .quick-settings {
            display: flex;
            gap: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .quick-setting-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Стили для файловых путей */
        .file-path {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 12px;
            word-break: break-all;
        }

        .file-path-icon {
            font-size: 16px;
        }

        /* Анимация для новых элементов */
        @keyframes slideInLeft {
            from {
                transform: translateX(-20px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .slide-in {
            animation: slideInLeft 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎬 AUTO MONTAGE BUILDER PRO - COMPLETE EDITION</h1>
        </div>

        <div class="tabs-container">
            <div class="tabs">
                <button class="tab active" data-tab="generation">🎬 Генерация</button>
                <button class="tab" data-tab="channels">📺 Каналы</button>
                <button class="tab" data-tab="effects">🎨 Эффекты</button>
                <button class="tab" data-tab="overlays">🎭 Оверлеи</button>
                <button class="tab" data-tab="capcut">✨ CapCut FX</button>
                <button class="tab" data-tab="settings">⚙️ Настройки</button>
            </div>
        </div>

        <!-- Вкладка Генерация -->
        <div class="tab-content active" id="generation">
            <div class="panel">
                <h3>📁 Папка проекта</h3>
                <div class="form-row">
                    <input type="text" id="projectPath" placeholder="Выберите папку с файлами (изображения/видео + аудио)" readonly>
                    <button class="btn btn-secondary" onclick="selectProjectFolder()">Обзор...</button>
                </div>
                <div class="checkbox-group" style="margin-top: 10px;">
                    <input type="checkbox" id="includeVideos" checked>
                    <label for="includeVideos">Включить видео файлы (MP4, MOV, AVI)</label>
                </div>
            </div>

            <div class="info-panel">
                <div class="info-text" id="projectInfo">Выберите папку проекта для начала работы.
Поддерживаются форматы:
• Изображения: JPG, PNG, TIFF, BMP
• Видео: MP4, MOV, AVI, MKV
• Аудио: MP3, WAV, M4A, FLAC</div>
            </div>

            <div class="panel">
                <h3>📺 Выбор каналов для генерации</h3>
                <div class="channel-list" id="generationChannelList">
                    <!-- Динамически генерируется -->
                </div>
                <div class="quick-settings">
                    <button class="btn btn-small btn-secondary" onclick="selectAllChannels()">Выбрать все</button>
                    <button class="btn btn-small btn-secondary" onclick="deselectAllChannels()">Снять выделение</button>
                </div>
            </div>

            <div class="panel">
                <h3>🎵 Подготовка аудио</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="processAudioFirst" checked>
                    <label for="processAudioFirst">Автоматически обработать аудио перед генерацией</label>
                </div>
                <div class="info-text" style="font-size: 12px; color: #999; margin-top: 10px;">
                    Для каждого канала будут созданы уникальные аудио файлы с заданными настройками тональности и эффектов
                </div>
            </div>

            <div class="btn-group">
                <button class="btn btn-secondary" onclick="testMontage()">🧪 Тест (1 пара)</button>
                <button class="btn btn-secondary" onclick="importFiles()">📂 Импорт в проект</button>
                <button class="btn btn-primary" onclick="generateMontage()" id="generateBtn">
                    🎬 СОЗДАТЬ МОНТАЖ
                </button>
            </div>

            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                    <div class="progress-text" id="progressText">Готов к работе</div>
                </div>
            </div>

            <div class="log-container" id="logContainer">
                <div class="log-entry log-info">Система готова к работе</div>
                <div class="log-entry log-info">Минимальные требования: Adobe Premiere Pro 2020+</div>
            </div>
        </div>

        <!-- Вкладка Каналы -->
        <div class="tab-content" id="channels">
            <div class="panel">
                <h3>📺 Управление каналами</h3>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="createChannel()">➕ Создать канал</button>
                    <button class="btn btn-secondary" onclick="importChannels()">📥 Импорт</button>
                    <button class="btn btn-secondary" onclick="exportChannels()">📤 Экспорт</button>
                    <button class="btn btn-secondary" onclick="createChannelFromTemplate()">📋 Из шаблона</button>
                </div>
            </div>

            <div class="panel">
                <h3>📋 Список каналов</h3>
                <div class="channel-list" id="channelList">
                    <!-- Динамически генерируется -->
                </div>
            </div>
        </div>

        <!-- Вкладка Эффекты -->
        <div class="tab-content" id="effects">
            <div class="panel">
                <h3>📺 Редактирование канала</h3>
                <select id="channelSelector" onchange="loadChannelEffects()">
                    <option value="">Выберите канал...</option>
                </select>
            </div>

            <div id="effectsEditor" style="display: none;">
                <div class="effects-columns">
                    <!-- Левая колонка -->
                    <div>
                        <!-- Настройки экспорта -->
                        <div class="panel">
                            <h3>📤 Настройки экспорта</h3>
                            <div class="form-row">
                                <label>Разрешение:</label>
                                <select id="channelResolution">
                                    <option value="1920x1080">1920×1080 (Full HD)</option>
                                    <option value="3840x2160">3840×2160 (4K)</option>
                                    <option value="1280x720">1280×720 (HD)</option>
                                    <option value="1080x1920">1080×1920 (Вертикальное)</option>
                                    <option value="1080x1080">1080×1080 (Квадрат)</option>
                                    <option value="custom">Пользовательское</option>
                                </select>
                            </div>
                            
                            <div id="customResolution" style="display: none;">
                                <div class="form-row">
                                    <label>Ширина:</label>
                                    <input type="number" id="customWidth" value="1920" min="320" max="7680">
                                    <label>Высота:</label>
                                    <input type="number" id="customHeight" value="1080" min="240" max="4320">
                                </div>
                            </div>
                            
                            <div class="form-row">
                                <label>FPS:</label>
                                <select id="channelFps">
                                    <option value="24">24</option>
                                    <option value="25">25</option>
                                    <option value="30" selected>30</option>
                                    <option value="50">50</option>
                                    <option value="60">60</option>
                                </select>
                            </div>
                            
                            <div class="form-row">
                                <label>Битрейт (Mbps):</label>
                                <input type="number" id="channelBitrate" value="8" min="1" max="100">
                            </div>
                            
                            <div class="form-row">
                                <label>Кодек:</label>
                                <select id="channelCodec">
                                    <option value="h264">H.264</option>
                                    <option value="h265">H.265/HEVC</option>
                                    <option value="prores">ProRes</option>
                                </select>
                            </div>
                        </div>

                        <!-- Ken Burns эффекты -->
                        <div class="panel">
                            <h3>🎬 Ken Burns эффекты</h3>
                            <div class="effects-list">
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_zoomIn" class="kb-effect">
                                    <label for="kb_zoomIn">Zoom In (приближение)</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_zoomOut" class="kb-effect">
                                    <label for="kb_zoomOut">Zoom Out (отдаление)</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_panLeft" class="kb-effect">
                                    <label for="kb_panLeft">Pan Left (влево)</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_panRight" class="kb-effect">
                                    <label for="kb_panRight">Pan Right (вправо)</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_panUp" class="kb-effect">
                                    <label for="kb_panUp">Pan Up (вверх)</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_panDown" class="kb-effect">
                                    <label for="kb_panDown">Pan Down (вниз)</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_rotate" class="kb-effect">
                                    <label for="kb_rotate">Rotate (вращение)</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="kb_diagonal" class="kb-effect">
                                    <label for="kb_diagonal">Diagonal (диагональ)</label>
                                </div>
                            </div>
                            
                            <div class="slider-group">
                                <label>Интенсивность:</label>
                                <input type="range" id="kbIntensity" class="slider" min="0" max="100" value="30">
                                <span class="slider-value" id="kbIntensityValue">30%</span>
                            </div>
                            
                            <div class="slider-group">
                                <label>Угол вращения:</label>
                                <input type="range" id="rotationAngle" class="slider" min="0" max="45" value="5">
                                <span class="slider-value" id="rotationAngleValue">5°</span>
                            </div>
                            
                            <div class="checkbox-group">
                                <input type="checkbox" id="kbSmartCrop" checked>
                                <label for="kbSmartCrop">Умная обрезка (без черных полос)</label>
                            </div>
                            
                            <div class="checkbox-group">
                                <input type="checkbox" id="kbRandomize">
                                <label for="kbRandomize">Рандомизировать направление для каждого клипа</label>
                            </div>
                        </div>

                        <!-- Аудио настройки -->
                        <div class="panel">
                            <h3>🎵 Аудио настройки</h3>
                            <div class="form-row">
                                <label>Тональность:</label>
                                <select id="audioPitch">
                                    <option value="-3">-3 (очень низкий)</option>
                                    <option value="-2">-2 (низкий)</option>
                                    <option value="-1.5">-1.5</option>
                                    <option value="-1">-1</option>
                                    <option value="-0.5">-0.5</option>
                                    <option value="0" selected>0 (оригинал)</option>
                                    <option value="+0.5">+0.5</option>
                                    <option value="+1">+1</option>
                                    <option value="+1.5">+1.5</option>
                                    <option value="+2">+2 (высокий)</option>
                                    <option value="+3">+3 (очень высокий)</option>
                                </select>
                            </div>
                            
                            <div class="form-row">
                                <label>Эффект:</label>
                                <select id="audioEffect">
                                    <option value="none">Без эффекта</option>
                                    <option value="bass">Усиление басов</option>
                                    <option value="reverb">Реверберация</option>
                                    <option value="echo">Эхо</option>
                                    <option value="chorus">Хорус</option>
                                    <option value="telephone">Телефон</option>
                                    <option value="underwater">Под водой</option>
                                    <option value="radio">Радио</option>
                                    <option value="vintage">Винтаж</option>
                                </select>
                            </div>
                            
                            <div class="checkbox-group">
                                <input type="checkbox" id="audioStereoEnhance">
                                <label for="audioStereoEnhance">Расширение стерео</label>
                            </div>
                            
                            <div class="checkbox-group">
                                <input type="checkbox" id="audioNormalize" checked>
                                <label for="audioNormalize">Нормализация громкости</label>
                            </div>
                        </div>
                    </div>

                    <!-- Правая колонка -->
                    <div>
                        <!-- Переходы -->
                        <div class="panel">
                            <h3>🔄 Переходы</h3>
                            <div class="effects-list">
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_fade" class="transition-effect">
                                    <label for="trans_fade">Fade</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_dissolve" class="transition-effect">
                                    <label for="trans_dissolve">Cross Dissolve</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_dip_black" class="transition-effect">
                                    <label for="trans_dip_black">Dip to Black</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_dip_white" class="transition-effect">
                                    <label for="trans_dip_white">Dip to White</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_wipe" class="transition-effect">
                                    <label for="trans_wipe">Wipe</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_slide" class="transition-effect">
                                    <label for="trans_slide">Slide</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_push" class="transition-effect">
                                    <label for="trans_push">Push</label>
                                </div>
                                <div class="effect-item">
                                    <input type="checkbox" id="trans_zoom" class="transition-effect">
                                    <label for="trans_zoom">Zoom</label>
                                </div>
                            </div>
                            
                            <div class="form-row">
                                <label>Длительность:</label>
                                <input type="number" id="transitionDuration" value="1.0" min="0.1" max="3.0" step="0.1">
                                <span>секунд</span>
                            </div>
                            
                            <div class="checkbox-group">
                                <input type="checkbox" id="transRandomize">
                                <label for="transRandomize">Случайный выбор переходов</label>
                            </div>
                        </div>

                        <!-- Цветокоррекция -->
                        <div class="panel">
                            <h3>🎨 Цветокоррекция</h3>
                            <div class="checkbox-group">
                                <input type="checkbox" id="enableColorCorrection">
                                <label for="enableColorCorrection">Включить цветокоррекцию</label>
                            </div>
                            
                            <div id="colorCorrectionSettings" style="display: none;">
                                <div class="form-row">
                                    <label>Фильтр:</label>
                                    <select id="colorFilter">
                                        <option value="none">Без фильтра</option>
                                        <option value="warm">Теплый</option>
                                        <option value="cold">Холодный</option>
                                        <option value="vintage">Винтаж</option>
                                        <option value="blackwhite">Черно-белый</option>
                                        <option value="sepia">Сепия</option>
                                        <option value="cinematic">Кинематографичный</option>
                                        <option value="vibrant">Насыщенный</option>
                                        <option value="faded">Выцветший</option>
                                    </select>
                                </div>
                                
                                <div class="checkbox-group">
                                    <input type="checkbox" id="enableVignette">
                                    <label for="enableVignette">Виньетка</label>
                                </div>
                                
                                <div class="slider-group" id="vignetteSettings" style="display: none;">
                                    <label>Интенсивность:</label>
                                    <input type="range" id="vignetteIntensity" class="slider" min="0" max="100" value="40">
                                    <span class="slider-value" id="vignetteIntensityValue">40%</span>
                                </div>
                                
                                <div class="checkbox-group">
                                    <input type="checkbox" id="enableGrain">
                                    <label for="enableGrain">Зерно пленки</label>
                                </div>
                                
                                <div class="slider-group" id="grainSettings" style="display: none;">
                                    <label>Интенсивность:</label>
                                    <input type="range" id="grainIntensity" class="slider" min="0" max="100" value="20">
                                    <span class="slider-value" id="grainIntensityValue">20%</span>
                                </div>
                            </div>
                        </div>

                        <!-- Плавность анимации -->
                        <div class="panel">
                            <h3>⚡ Плавность анимации</h3>
                            <div class="form-row">
                                <label>Тип интерполяции:</label>
                                <select id="easingType">
                                    <option value="linear">Линейная</option>
                                    <option value="ease" selected>Плавная</option>
                                    <option value="ease-in">Ускорение</option>
                                    <option value="ease-out">Замедление</option>
                                    <option value="ease-in-out">Ускорение и замедление</option>
                                    <option value="bezier">Кривая Безье</option>
                                    <option value="bounce">Отскок</option>
                                    <option value="elastic">Эластичная</option>
                                </select>
                            </div>
                            
                            <div id="bezierSettings" style="display: none;">
                                <div class="slider-group">
                                    <label>Точка 1:</label>
                                    <input type="range" id="bezierP1" class="slider" min="0" max="100" value="25">
                                    <span class="slider-value" id="bezierP1Value">25</span>
                                </div>
                                <div class="slider-group">
                                    <label>Точка 2:</label>
                                    <input type="range" id="bezierP2" class="slider" min="0" max="100" value="75">
                                    <span class="slider-value" id="bezierP2Value">75</span>
                                </div>
                            </div>
                        </div>

                        <!-- 3D эффекты -->
                        <div class="panel">
                            <h3>🎯 3D эффекты</h3>
                            <div class="checkbox-group">
                                <input type="checkbox" id="enable3D">
                                <label for="enable3D">Включить 3D движение</label>
                            </div>
                            
                            <div id="3dSettings" style="display: none;">
                                <div class="form-row">
                                    <label>Тип 3D:</label>
                                    <select id="3dType">
                                        <option value="basic">Базовый поворот</option>
                                        <option value="parallax">Параллакс (слои)</option>
                                        <option value="depth">Глубина (требует обработки)</option>
                                    </select>
                                </div>
                                
                                <div class="slider-group">
                                    <label>Интенсивность:</label>
                                    <input type="range" id="3dIntensity" class="slider" min="0" max="100" value="20">
                                    <span class="slider-value" id="3dIntensityValue">20%</span>
                                </div>
                                
                                <div class="checkbox-group">
                                    <input type="checkbox" id="3dAutoRotate">
                                    <label for="3dAutoRotate">Автовращение</label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="btn-group">
                    <button class="btn btn-primary" onclick="saveChannelEffects()">💾 Сохранить настройки</button>
                    <button class="btn btn-secondary" onclick="resetChannelEffects()">🔄 Сбросить</button>
                    <button class="btn btn-secondary" onclick="previewEffects()">👁️ Предпросмотр</button>
                    <button class="btn btn-secondary" onclick="duplicateToChannel()">📋 Копировать в...</button>
                </div>
            </div>
        </div>

        <!-- Вкладка Оверлеи -->
        <div class="tab-content" id="overlays">
            <div class="panel">
                <h3>🎭 Управление оверлеями</h3>
                <div class="form-row">
                    <label>Папка с оверлеями:</label>
                    <input type="text" id="overlaysPath" placeholder="Выберите папку с оверлеями" readonly>
                    <button class="btn btn-secondary" onclick="selectOverlaysFolder()">Обзор...</button>
                </div>
                <div class="info-text" style="margin-top: 10px; font-size: 12px;">
                    Поддерживаются: PNG (с прозрачностью), MP4, MOV, GIF
                </div>
            </div>

            <div class="panel">
                <h3>📺 Назначение оверлеев каналам</h3>
                <select id="overlayChannelSelector" onchange="loadChannelOverlays()">
                    <option value="">Выберите канал...</option>
                </select>
                
                <div id="overlaySettings" style="display: none; margin-top: 20px;">
                    <div class="panel">
                        <h3>Доступные оверлеи</h3>
                        <div id="overlaysList" class="effects-list">
                            <!-- Динамически заполняется -->
                        </div>
                    </div>
                    
                    <div class="panel">
                        <h3>Настройки наложения</h3>
                        <div class="form-row">
                            <label>Режим наложения:</label>
                            <select id="overlayBlendMode">
                                <option value="normal">Normal</option>
                                <option value="screen">Screen (для бликов)</option>
                                <option value="overlay">Overlay</option>
                                <option value="multiply">Multiply</option>
                                <option value="add">Add</option>
                                <option value="lighten">Lighten</option>
                                <option value="darken">Darken</option>
                            </select>
                        </div>
                        
                        <div class="slider-group">
                            <label>Прозрачность:</label>
                            <input type="range" id="overlayOpacity" class="slider" min="0" max="100" value="100">
                            <span class="slider-value" id="overlayOpacityValue">100%</span>
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="overlayRandomize">
                            <label for="overlayRandomize">Случайный выбор оверлеев</label>
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="overlayStretch" checked>
                            <label for="overlayStretch">Растягивать на весь экран</label>
                        </div>
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="saveOverlaySettings()">💾 Сохранить</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Вкладка CapCut эффекты -->
        <div class="tab-content" id="capcut">
            <div class="panel">
                <h3>✨ CapCut-style эффекты</h3>
                <select id="capcutChannelSelector" onchange="loadChannelCapcutEffects()">
                    <option value="">Выберите канал...</option>
                </select>
            </div>

            <div id="capcutEffectsEditor" style="display: none;">
                <div class="effects-columns">
                    <!-- Анимации масштаба -->
                    <div class="panel">
                        <h3>🔍 Анимации масштаба</h3>
                        <div class="effects-list">
                            <div class="effect-item">
                                <input type="checkbox" id="fx_zoomBurst" class="capcut-effect">
                                <label for="fx_zoomBurst">Zoom Burst (резкий зум)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_pulse" class="capcut-effect">
                                <label for="fx_pulse">Pulse (пульсация)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_bounce" class="capcut-effect">
                                <label for="fx_bounce">Bounce (отскок)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_elastic" class="capcut-effect">
                                <label for="fx_elastic">Elastic (эластичный)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_wave" class="capcut-effect">
                                <label for="fx_wave">Wave (волна)</label>
                            </div>
                        </div>
                        
                        <div class="slider-group">
                            <label>Амплитуда:</label>
                            <input type="range" id="scaleAmplitude" class="slider" min="0" max="50" value="15">
                            <span class="slider-value" id="scaleAmplitudeValue">15%</span>
                        </div>
                        
                        <div class="settings-section">
                            <h4>Настройки Zoom Burst</h4>
                            <div class="slider-group">
                                <label>Начальный зум:</label>
                                <input type="range" id="zoomBurstStart" class="slider" min="100" max="200" value="150">
                                <span class="slider-value" id="zoomBurstStartValue">150%</span>
                            </div>
                            <div class="slider-group">
                                <label>Скорость затухания:</label>
                                <input type="range" id="zoomBurstDecay" class="slider" min="0" max="100" value="80">
                                <span class="slider-value" id="zoomBurstDecayValue">80%</span>
                            </div>
                        </div>
                    </div>

                    <!-- Движение и тряска -->
                    <div class="panel">
                        <h3>🎯 Движение и тряска</h3>
                        <div class="effects-list">
                            <div class="effect-item">
                                <input type="checkbox" id="fx_shake" class="capcut-effect">
                                <label for="fx_shake">Shake (тряска)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_wobble" class="capcut-effect">
                                <label for="fx_wobble">Wobble (покачивание)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_pendulum" class="capcut-effect">
                                <label for="fx_pendulum">Pendulum (маятник)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_swing" class="capcut-effect">
                                <label for="fx_swing">Swing (раскачивание)</label>
                            </div>
                            <div class="effect-item">
                                <input type="checkbox" id="fx_glitch" class="capcut-effect">
                                <label for="fx_glitch">Glitch (глитч)</label>
                            </div>
                        </div>
                        
                        <div class="slider-group">
                            <label>Интенсивность:</label>
                            <input type="range" id="motionIntensity" class="slider" min="0" max="100" value="30">
                            <span class="slider-value" id="motionIntensityValue">30%</span>
                        </div>
                    </div>
                </div>

                <!-- Частота применения -->
                <div class="panel">
                    <h3>📊 Частота применения эффектов</h3>
                    <div class="form-row">
                        <label>Применять к:</label>
                        <select id="effectFrequency">
                            <option value="all">Всем клипам</option>
                            <option value="percent">Проценту клипов</option>
                            <option value="every">Каждому N-му клипу</option>
                            <option value="random">Случайно</option>
                        </select>
                    </div>
                    
                    <div id="frequencySettings">
                        <div class="slider-group" id="percentSettings" style="display: none;">
                            <label>Процент клипов:</label>
                            <input type="range" id="effectPercent" class="slider" min="0" max="100" value="50">
                            <span class="slider-value" id="effectPercentValue">50%</span>
                        </div>
                        
                        <div class="form-row" id="everySettings" style="display: none;">
                            <label>Каждый:</label>
                            <input type="number" id="effectEvery" value="3" min="2" max="10">
                            <span>клип</span>
                        </div>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="avoidRepetition" checked>
                        <label for="avoidRepetition">Избегать повторения эффектов подряд</label>
                    </div>
                </div>

                <div class="btn-group">
                    <button class="btn btn-primary" onclick="saveCapcutEffects()">💾 Сохранить</button>
                    <button class="btn btn-secondary" onclick="presetCapcutEffects('dynamic')">🎬 Пресет: Динамичный</button>
                    <button class="btn btn-secondary" onclick="presetCapcutEffects('smooth')">🌊 Пресет: Плавный</button>
                    <button class="btn btn-secondary" onclick="presetCapcutEffects('epic')">⚡ Пресет: Эпичный</button>
                </div>
            </div>
        </div>

        <!-- Вкладка Настройки -->
        <div class="tab-content" id="settings">
            <div class="panel">
                <h3>📁 Пути к программам</h3>
                <div class="form-group">
                    <label>FFmpeg:</label>
                    <div class="form-row">
                        <input type="text" id="ffmpegPath" value="ffmpeg.exe">
                        <button class="btn btn-secondary" onclick="browsePath('ffmpeg')">...</button>
                        <button class="btn btn-small btn-secondary" onclick="downloadFFmpeg()">⬇️ Скачать</button>
                    </div>
                    <div class="info-text" style="font-size: 11px; color: #999; margin-top: 5px;">
                        Используется для обработки аудио
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Media Encoder:</label>
                    <div class="form-row">
                        <input type="text" id="amePath" value="">
                        <button class="btn btn-secondary" onclick="browsePath('ame')">...</button>
                        <button class="btn btn-small btn-secondary" onclick="findMediaEncoder()">🔍 Найти</button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Python (для 3D эффектов):</label>
                    <div class="form-row">
                        <input type="text" id="pythonPath" value="python">
                        <button class="btn btn-secondary" onclick="browsePath('python')">...</button>
                        <button class="btn btn-small btn-secondary" onclick="checkPython()">✓ Проверить</button>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>⚡ Производительность</h3>
                <div class="slider-group">
                    <label>Потоки рендеринга:</label>
                    <input type="range" id="renderThreads" class="slider" min="1" max="16" value="4">
                    <span class="slider-value" id="renderThreadsValue">4</span>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="useGPU" checked>
                    <label for="useGPU">Использовать GPU ускорение</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="useProxies">
                    <label for="useProxies">Создавать прокси для 4K видео</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="preRenderEffects">
                    <label for="preRenderEffects">Предварительный рендер сложных эффектов</label>
                </div>
            </div>

            <div class="panel">
                <h3>🌐 Обработка файлов</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="transcodeRussian" checked>
                    <label for="transcodeRussian">Автоматически перекодировать русские названия</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="keepOriginals" checked>
                    <label for="keepOriginals">Сохранять оригинальные файлы</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="cleanupTemp">
                    <label for="cleanupTemp">Удалять временные файлы после генерации</label>
                </div>
            </div>

            <div class="panel">
                <h3>🎯 Настройки по умолчанию</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="autoSave" checked>
                    <label for="autoSave">Автосохранение проекта каждые 5 минут</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="autoBackup">
                    <label for="autoBackup">Создавать резервные копии проекта</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showNotifications" checked>
                    <label for="showNotifications">Показывать уведомления о завершении</label>
                </div>
            </div>

            <div class="btn-group">
                <button class="btn btn-primary" onclick="saveSettings()">💾 Сохранить настройки</button>
                <button class="btn btn-secondary" onclick="resetSettings()">🔄 Сбросить</button>
                <button class="btn btn-secondary" onclick="exportSettings()">📤 Экспорт</button>
                <button class="btn btn-secondary" onclick="importSettings()">📥 Импорт</button>
            </div>

            <div class="panel" style="margin-top: 30px;">
                <h3>ℹ️ О программе</h3>
                <div class="info-text">
                    <strong>Auto Montage Builder Pro - Complete Edition</strong><br>
                    Версия: 4.0.0<br>
                    Оптимизировано для Adobe Premiere Pro 2020+<br><br>
                    
                    <strong>Возможности:</strong><br>
                    • Автоматическая расстановка файлов на таймлайне<br>
                    • Поддержка видео файлов с зацикливанием<br>
                    • Система каналов для YouTube<br>
                    • Ken Burns эффекты с защитой от черных полос<br>
                    • CapCut-style анимации<br>
                    • Видео и изображения оверлеи<br>
                    • Настраиваемые переходы<br>
                    • Обработка аудио с эффектами<br>
                    • 3D эффекты (базовые и продвинутые)<br>
                    • Автоматическая обработка русских путей<br><br>
                    
                    <strong>Поддержка:</strong> automontage@support.com
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно создания канала -->
    <div class="modal" id="channelModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Создание нового канала</h2>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Название канала:</label>
                    <input type="text" id="newChannelName" placeholder="Например: Мой основной канал">
                </div>
                <div class="form-group">
                    <label>Описание:</label>
                    <input type="text" id="newChannelDescription" placeholder="Краткое описание канала">
                </div>
                <div class="form-group">
                    <label>Базовый шаблон:</label>
                    <select id="newChannelTemplate">
                        <option value="youtube">YouTube (горизонтальное)</option>
                        <option value="shorts">Shorts/Reels (вертикальное)</option>
                        <option value="square">Instagram (квадрат)</option>
                        <option value="custom">Пользовательский</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('channelModal')">Отмена</button>
                <button class="btn btn-primary" onclick="saveNewChannel()">Создать</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно выбора шаблона -->
    <div class="modal" id="templateModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Выберите шаблон канала</h2>
            </div>
            <div class="modal-body">
                <div class="channel-list">
                    <div class="channel-card" onclick="createFromTemplate('dynamic')">
                        <div class="channel-name">🎬 Динамичный</div>
                        <div class="channel-info">Много движения, быстрые переходы, эффекты CapCut</div>
                    </div>
                    <div class="channel-card" onclick="createFromTemplate('cinematic')">
                        <div class="channel-name">🎥 Кинематографичный</div>
                        <div class="channel-info">Плавные движения, цветокоррекция, виньетка</div>
                    </div>
                    <div class="channel-card" onclick="createFromTemplate('minimal')">
                        <div class="channel-name">⚪ Минималистичный</div>
                        <div class="channel-info">Простые переходы, без лишних эффектов</div>
                    </div>
                    <div class="channel-card" onclick="createFromTemplate('retro')">
                        <div class="channel-name">📼 Ретро</div>
                        <div class="channel-info">Винтажные фильтры, зерно, старая пленка</div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('templateModal')">Отмена</button>
            </div>
        </div>
    </div>

    <!-- Кнопка отмены -->
    <button class="cancel-button" id="cancelButton" onclick="cancelGeneration()">✕</button>

    <script>
        // Глобальная инициализация CSInterface
        var csInterface = null;
        
        // Ждем полной загрузки страницы
        window.addEventListener('load', function() {
            setTimeout(function() {
                if (typeof CSInterface !== 'undefined') {
                    try {
                        csInterface = new CSInterface();
                        console.log('CSInterface создан после загрузки страницы');
                    } catch(e) {
                        console.error('Ошибка создания CSInterface:', e);
                    }
                }
            }, 100);
        });
        
        // Глобальные переменные
        let PROJECT_FOLDER = null;
        let AUDIO_VARIANTS_FOLDER = null;
        let RENDERS_FOLDER = null;
        let OVERLAYS_FOLDER = null;
        let channels = [];
        let selectedChannels = new Set();
        let currentChannelId = null;
        let isGenerating = false;
        let generationAborted = false;
        let overlayFiles = [];

        // Инициализация
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM загружен, начинаем инициализацию...');
            
            // Дополнительная проверка CSInterface
            if (typeof CSInterface === 'undefined') {
                log('⚠️ CSInterface не определен при загрузке DOM', 'warning');
                
                // Пробуем загрузить альтернативным способом
                if (window.__adobe_cep__) {
                    log('🔍 Обнаружен __adobe_cep__, пробуем инициализацию...', 'info');
                    
                    // Загружаем CSInterface динамически
                    var script = document.createElement('script');
                    script.src = './js/CSInterface.js';
                    script.onload = function() {
                        log('✅ CSInterface.js загружен динамически', 'info');
                        if (typeof CSInterface !== 'undefined') {
                            try {
                                csInterface = new CSInterface();
                                log('✅ CSInterface создан успешно!', 'info');
                                checkEnvironment();
                            } catch(e) {
                                log('❌ Ошибка создания CSInterface: ' + e.message, 'error');
                            }
                        }
                    };
                    script.onerror = function() {
                        log('❌ Не удалось загрузить CSInterface.js', 'error');
                    };
                    document.head.appendChild(script);
                }
            } else {
                log('✅ CSInterface доступен при загрузке DOM', 'info');
                try {
                    csInterface = new CSInterface();
                    log('✅ CSInterface успешно создан', 'info');
                } catch(e) {
                    log('❌ Ошибка создания CSInterface: ' + e.message, 'error');
                }
            }
            
            initializeTabs();
            loadChannels();
            loadSettings();
            setupEventListeners();
            
            // Откладываем проверку окружения
            setTimeout(checkEnvironment, 500);
            
            // Отладка
            console.log('Количество каналов:', channels.length);
            console.log('Каналы:', channels);
        });

        // Проверка окружения
        function checkEnvironment() {
            // Небольшая задержка для гарантии загрузки
            setTimeout(function() {
                if (typeof CSInterface !== 'undefined' && !csInterface) {
                    try {
                        csInterface = new CSInterface();
                        log('✅ CSInterface создан в checkEnvironment', 'info');
                    } catch(e) {
                        log('❌ Ошибка создания CSInterface: ' + e.message, 'error');
                    }
                }
                
                if (csInterface) {
                    log('✅ CSInterface доступен и готов к работе', 'info');
                    
                    // Проверяем работу evalScript
                    csInterface.evalScript('app.project ? "OK" : "NO_PROJECT"', function(result) {
                        if (result === 'OK') {
                            log('✅ Подключение к Premiere Pro установлено', 'info');
                        } else if (result === 'NO_PROJECT') {
                            log('⚠️ Premiere Pro подключен, но нет активного проекта', 'warning');
                        } else {
                            log('❌ Не удалось подключиться к Premiere Pro', 'error');
                        }
                    });
                    
                    // Проверяем версию
                    csInterface.evalScript('app.version', function(version) {
                        if (version && version !== 'undefined') {
                            log(`Adobe Premiere Pro ${version}`, 'info');
                        }
                    });
                } else {
                    log('❌ CSInterface не доступен - работа в режиме симуляции', 'warning');
                }
            }, 200);
        }

        // Управление вкладками
        function initializeTabs() {
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetTab = tab.dataset.tab;
                    
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));
                    
                    tab.classList.add('active');
                    const targetContent = document.getElementById(targetTab);
                    if (targetContent) {
                        targetContent.classList.add('active');
                    } else {
                        console.error('Вкладка не найдена:', targetTab);
                    }
                });
            });
        }

        // Настройка слушателей событий
        function setupEventListeners() {
            // Слайдеры
            document.querySelectorAll('.slider').forEach(slider => {
                slider.addEventListener('input', function() {
                    const valueSpan = document.getElementById(this.id + 'Value');
                    if (valueSpan) {
                        let value = this.value;
                        if (this.id.includes('Angle')) {
                            value += '°';
                        } else if (this.id !== 'renderThreads' && !this.id.includes('bezier')) {
                            value += '%';
                        }
                        valueSpan.textContent = value;
                    }
                });
            });

            // Чекбоксы цветокоррекции
            document.getElementById('enableColorCorrection').addEventListener('change', function() {
                document.getElementById('colorCorrectionSettings').style.display = 
                    this.checked ? 'block' : 'none';
            });

            document.getElementById('enableVignette').addEventListener('change', function() {
                document.getElementById('vignetteSettings').style.display = 
                    this.checked ? 'block' : 'none';
            });

            document.getElementById('enableGrain').addEventListener('change', function() {
                document.getElementById('grainSettings').style.display = 
                    this.checked ? 'block' : 'none';
            });

            // 3D настройки
            document.getElementById('enable3D').addEventListener('change', function() {
                document.getElementById('3dSettings').style.display = 
                    this.checked ? 'block' : 'none';
            });

            // Интерполяция
            document.getElementById('easingType').addEventListener('change', function() {
                document.getElementById('bezierSettings').style.display = 
                    this.value === 'bezier' ? 'block' : 'none';
            });

            // Частота эффектов
            document.getElementById('effectFrequency').addEventListener('change', function() {
                document.getElementById('percentSettings').style.display = 'none';
                document.getElementById('everySettings').style.display = 'none';
                
                if (this.value === 'percent') {
                    document.getElementById('percentSettings').style.display = 'block';
                } else if (this.value === 'every') {
                    document.getElementById('everySettings').style.display = 'block';
                }
            });

            // Разрешение
            document.getElementById('channelResolution').addEventListener('change', function() {
                document.getElementById('customResolution').style.display = 
                    this.value === 'custom' ? 'block' : 'none';
            });
        }

        // Логирование
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type} slide-in`;
            
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            while (logContainer.children.length > 100) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }

        // Обновление прогресса
        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        // === РАБОТА С ПАПКОЙ ПРОЕКТА ===
        
        function selectProjectFolder() {
            // Проверяем среду выполнения
            if (window.cep && window.cep.fs) {
                // CEP окружение
                const result = window.cep.fs.showOpenDialogEx(false, true, "Выберите папку проекта", "");
                if (result.data && result.data.length > 0) {
                    PROJECT_FOLDER = result.data[0];
                    document.getElementById('projectPath').value = PROJECT_FOLDER;
                    
                    AUDIO_VARIANTS_FOLDER = PROJECT_FOLDER + "/audio_variants";
                    RENDERS_FOLDER = PROJECT_FOLDER + "/renders";
                    
                    createSubfolders();
                    scanProjectFolder();
                }
            } else {
                // Браузерный режим - симуляция
                const simulatedPath = prompt("Введите путь к папке проекта:", "C:/Projects/AutoMontage");
                if (simulatedPath) {
                    PROJECT_FOLDER = simulatedPath;
                    document.getElementById('projectPath').value = simulatedPath;
                    
                    AUDIO_VARIANTS_FOLDER = PROJECT_FOLDER + "/audio_variants";
                    RENDERS_FOLDER = PROJECT_FOLDER + "/renders";
                    
                    // Симуляция результатов сканирования
                    updateProjectInfo({
                        images: 5,
                        videos: 3,
                        audio: 8,
                        pairs: 5
                    });
                    
                    window.lastScanResult = {
                        pairs: [
                            {number: '0001', mediaType: 'image', mediaFile: {name: '0001_image.jpg'}, audioFile: {name: '0001_audio.mp3'}},
                            {number: '0002', mediaType: 'image', mediaFile: {name: '0002_image.jpg'}, audioFile: {name: '0002_audio.mp3'}},
                            {number: '0003', mediaType: 'video', mediaFile: {name: '0003_video.mp4'}, audioFile: {name: '0003_audio.mp3'}},
                            {number: '0004', mediaType: 'image', mediaFile: {name: '0004_image.jpg'}, audioFile: {name: '0004_audio.mp3'}},
                            {number: '0005', mediaType: 'video', mediaFile: {name: '0005_video.mp4'}, audioFile: {name: '0005_audio.mp3'}}
                        ]
                    };
                    
                    log('Папка проекта выбрана: ' + simulatedPath, 'info');
                }
            }
        }

        function createSubfolders() {
            if (!PROJECT_FOLDER) return;
            
            const extScript = `
                var audioVariantsDir = new Folder("${AUDIO_VARIANTS_FOLDER.replace(/\\/g, '\\\\')}");
                if (!audioVariantsDir.exists) audioVariantsDir.create();
                
                var rendersDir = new Folder("${RENDERS_FOLDER.replace(/\\/g, '\\\\')}");
                if (!rendersDir.exists) rendersDir.create();
                
                "Подпапки созданы";
            `;
            
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                csInterface.evalScript(extScript, function(result) {
                    log('Подпапки проекта созданы', 'info');
                });
            }
        }

        function scanProjectFolder() {
            if (!PROJECT_FOLDER) return;
            
            updateProgress(10, "Сканирование папки...");
            console.log('Начинаем сканирование папки:', PROJECT_FOLDER);
            
            const includeVideos = document.getElementById('includeVideos').checked;
            
            // Для CEP окружения
            if (window.cep && window.cep.fs) {
                const folderPath = PROJECT_FOLDER;
                const result = window.cep.fs.readdir(folderPath);
                
                if (result.err === 0) {
                    const files = result.data;
                    console.log('Найдено файлов:', files.length);
                    
                    let images = 0, videos = 0, audio = 0;
                    const pairs = [];
                    const mediaFiles = {};
                    const audioFiles = {};
                    
                    files.forEach(fileName => {
                        const ext = fileName.substring(fileName.lastIndexOf('.')).toLowerCase();
                        const baseNumber = fileName.match(/^(\d{4})/);
                        
                        if (['.jpg', '.jpeg', '.png', '.tiff', '.bmp', '.tif'].includes(ext)) {
                            images++;
                            if (baseNumber) mediaFiles[baseNumber[1]] = {type: 'image', name: fileName};
                        } else if (includeVideos && ['.mp4', '.mov', '.avi', '.mkv'].includes(ext)) {
                            videos++;
                            if (baseNumber) mediaFiles[baseNumber[1]] = {type: 'video', name: fileName};
                        } else if (['.mp3', '.wav', '.aiff', '.m4a', '.flac'].includes(ext)) {
                            audio++;
                            if (baseNumber) audioFiles[baseNumber[1]] = fileName;
                        }
                    });
                    
                    // Считаем пары
                    Object.keys(mediaFiles).forEach(num => {
                        if (audioFiles[num]) {
                            pairs.push({
                                number: num,
                                mediaType: mediaFiles[num].type,
                                mediaFile: {name: mediaFiles[num].name},
                                audioFile: {name: audioFiles[num]}
                            });
                        }
                    });
                    
                    // Сортируем по номеру
                    pairs.sort((a, b) => parseInt(a.number) - parseInt(b.number));
                    
                    const scanResult = {images, videos, audio, pairs};
                    console.log('Результат сканирования:', scanResult);
                    
                    updateProgress(0, "Готов к работе");
                    updateProjectInfo(scanResult);
                    window.lastScanResult = scanResult;
                    
                } else {
                    console.error('Ошибка чтения папки:', result.err);
                    log('Ошибка чтения папки', 'error');
                }
                
            } else if (typeof CSInterface !== 'undefined') {
                // Старый способ через ExtendScript
                const extScript = `
                    function scanFolder(folderPath, includeVideos) {
                        try {
                            var folder = new Folder(folderPath);
                            if (!folder.exists) {
                                return {images: 0, videos: 0, audio: 0, pairs: 0, error: "Папка не существует"};
                            }
                            
                            var images = 0;
                            var videos = 0;
                            var audio = 0;
                            var pairs = [];
                            var mediaFiles = {};
                            var audioFiles = {};
                            
                            var files = folder.getFiles();
                            var supportedImageFormats = ['.jpg', '.jpeg', '.png', '.tiff', '.bmp', '.tif'];
                            var supportedVideoFormats = ['.mp4', '.mov', '.avi', '.mkv'];
                            var supportedAudioFormats = ['.mp3', '.wav', '.aiff', '.m4a', '.flac'];
                            
                            // Сканируем файлы
                            for (var i = 0; i < files.length; i++) {
                                if (files[i] instanceof File) {
                                    var fileName = files[i].name;
                                    var ext = fileName.substr(fileName.lastIndexOf('.')).toLowerCase();
                                    var baseNumber = fileName.match(/^(\\d{4})/);
                                    
                                    if (supportedImageFormats.indexOf(ext) > -1) {
                                        images++;
                                        if (baseNumber) mediaFiles[baseNumber[1]] = {type: 'image', file: files[i]};
                                    } else if (includeVideos && supportedVideoFormats.indexOf(ext) > -1) {
                                        videos++;
                                        if (baseNumber) mediaFiles[baseNumber[1]] = {type: 'video', file: files[i]};
                                    } else if (supportedAudioFormats.indexOf(ext) > -1) {
                                        audio++;
                                        if (baseNumber) audioFiles[baseNumber[1]] = files[i];
                                    }
                                }
                            }
                            
                            // Считаем пары
                            for (var num in mediaFiles) {
                                if (audioFiles[num]) {
                                    pairs.push({
                                        number: num,
                                        mediaType: mediaFiles[num].type,
                                        mediaFile: mediaFiles[num].file,
                                        audioFile: audioFiles[num]
                                    });
                                }
                            }
                            
                            // Сортируем по номеру
                            pairs.sort(function(a, b) {
                                return parseInt(a.number) - parseInt(b.number);
                            });
                            
                            return {
                                images: images,
                                videos: videos,
                                audio: audio,
                                pairs: pairs
                            };
                            
                        } catch(e) {
                            return {images: 0, videos: 0, audio: 0, pairs: 0, error: e.toString()};
                        }
                    }
                    
                    JSON.stringify(scanFolder("${PROJECT_FOLDER.replace(/\\/g, '\\\\')}", ${includeVideos}));
                `;
                
                const csInterface = new CSInterface();
                csInterface.evalScript(extScript, function(result) {
                    try {
                        const scanResult = JSON.parse(result);
                        console.log('Результат сканирования (ExtendScript):', scanResult);
                        updateProgress(0, "Готов к работе");
                        updateProjectInfo(scanResult);
                        
                        // Сохраняем результат для использования при генерации
                        window.lastScanResult = scanResult;
                    } catch(e) {
                        log('Ошибка сканирования: ' + e.message, 'error');
                    }
                });
            } else {
                // Браузерный режим - симуляция
                console.log('Браузерный режим - используем симуляцию');
                updateProjectInfo({
                    images: 5,
                    videos: 3,
                    audio: 8,
                    pairs: 5
                });
                
                window.lastScanResult = {
                    pairs: [
                        {number: '0001', mediaType: 'image', mediaFile: {name: '0001_image.jpg'}, audioFile: {name: '0001_audio.mp3'}},
                        {number: '0002', mediaType: 'image', mediaFile: {name: '0002_image.jpg'}, audioFile: {name: '0002_audio.mp3'}},
                        {number: '0003', mediaType: 'video', mediaFile: {name: '0003_video.mp4'}, audioFile: {name: '0003_audio.mp3'}},
                        {number: '0004', mediaType: 'image', mediaFile: {name: '0004_image.jpg'}, audioFile: {name: '0004_audio.mp3'}},
                        {number: '0005', mediaType: 'video', mediaFile: {name: '0005_video.mp4'}, audioFile: {name: '0005_audio.mp3'}}
                    ]
                };
            }
        }

        function updateProjectInfo(scanResult) {
            let info = "📊 Результаты сканирования:\n\n";
            info += `✅ Изображений: ${scanResult.images}\n`;
            if (scanResult.videos > 0) {
                info += `🎥 Видео: ${scanResult.videos}\n`;
            }
            info += `🎵 Аудио файлов: ${scanResult.audio}\n`;
            info += `📎 Готовых пар: ${scanResult.pairs ? scanResult.pairs.length : scanResult.pairs}`;
            
            if (scanResult.error) {
                info += `\n\n⚠️ Ошибка: ${scanResult.error}`;
            }
            
            document.getElementById('projectInfo').textContent = info;
            log(`Найдено пар файлов: ${scanResult.pairs ? scanResult.pairs.length : scanResult.pairs}`, 'info');
        }

        // === РАБОТА С КАНАЛАМИ ===

        function loadChannels() {
            const stored = localStorage.getItem('autoMontageChannels');
            console.log('Загрузка каналов из localStorage:', stored);
            
            if (stored) {
                try {
                    channels = JSON.parse(stored);
                    console.log('Каналы загружены:', channels);
                } catch(e) {
                    console.error('Ошибка парсинга каналов:', e);
                    channels = getDefaultChannels();
                }
            } else {
                console.log('Нет сохраненных каналов, создаем по умолчанию');
                channels = getDefaultChannels();
            }
            
            // Проверяем что каналы - это массив
            if (!Array.isArray(channels)) {
                console.error('Каналы не являются массивом:', channels);
                channels = getDefaultChannels();
            }
            
            // Если массив пустой, добавляем канал по умолчанию
            if (channels.length === 0) {
                console.log('Массив каналов пуст, добавляем канал по умолчанию');
                channels = getDefaultChannels();
            }
            
            saveChannels(); // Сохраняем на всякий случай
            updateChannelLists();
        }

        function getDefaultChannels() {
            try {
                return [
                    {
                        id: 'channel_' + Date.now(),
                        name: 'Основной канал',
                        description: 'Главный YouTube канал',
                        template: 'youtube',
                        export: {
                            resolution: '1920x1080',
                            customWidth: 1920,
                            customHeight: 1080,
                            fps: 30,
                            bitrate: 8,
                            codec: 'h264'
                        },
                        effects: {
                            // Ken Burns
                            kenBurns: ['zoomIn', 'panRight'],
                            kenBurnsIntensity: 30,
                            rotationAngle: 5,
                            smartCrop: true,
                            kbRandomize: false,
                            
                            // Переходы
                            transitions: ['fade', 'dissolve'],
                            transitionDuration: 1.0,
                            transRandomize: false,
                            
                            // Цветокоррекция
                            colorCorrection: true,
                            colorFilter: 'warm',
                            vignette: true,
                            vignetteIntensity: 40,
                            grain: false,
                            grainIntensity: 20,
                            
                            // Аудио
                            audioPitch: '-0.5',
                            audioEffect: 'bass',
                            audioStereoEnhance: true,
                            audioNormalize: true,
                            
                            // Анимация
                            easingType: 'ease',
                            bezierP1: 25,
                            bezierP2: 75,
                            
                            // 3D
                            enable3D: false,
                            type3D: 'basic',
                            intensity3D: 20,
                            autoRotate3D: false,
                            
                            // CapCut эффекты
                            capcutEffects: ['zoomBurst'],
                            scaleAmplitude: 15,
                            zoomBurstStart: 150,
                            zoomBurstDecay: 80,
                            motionEffects: [],
                            motionIntensity: 30,
                            effectFrequency: 'percent',
                            effectPercent: 30,
                            effectEvery: 3,
                            avoidRepetition: true
                        },
                        overlays: {
                            enabled: false,
                            files: [],
                            blendMode: 'screen',
                            opacity: 100,
                            randomize: false,
                            stretch: true
                        }
                    }
                ];
            } catch(e) {
                console.error('Ошибка создания канала по умолчанию:', e);
                return [];
            }
        }

        function saveChannels() {
            localStorage.setItem('autoMontageChannels', JSON.stringify(channels));
        }

        function updateChannelLists() {
            console.log('Обновление списков каналов, всего каналов:', channels.length);
            
            // Обновляем список каналов на вкладке управления
            const channelList = document.getElementById('channelList');
            if (channelList) {
                channelList.innerHTML = '';
                
                channels.forEach(channel => {
                    const card = document.createElement('div');
                    card.className = 'channel-card';
                    card.innerHTML = `
                        <div class="channel-name">${channel.name}</div>
                        <div class="channel-info">${channel.description || 'Без описания'}</div>
                        <div class="channel-info">${channel.export.resolution} • ${channel.export.fps}fps • ${channel.export.bitrate}Mbps</div>
                        <div class="channel-actions">
                            <button class="channel-action-btn" onclick="editChannel('${channel.id}')" title="Редактировать">✏️</button>
                            <button class="channel-action-btn" onclick="duplicateChannel('${channel.id}')" title="Дублировать">📋</button>
                            <button class="channel-action-btn" onclick="deleteChannel('${channel.id}')" title="Удалить">🗑️</button>
                        </div>
                    `;
                    channelList.appendChild(card);
                });
            } else {
                console.error('Элемент channelList не найден');
            }
            
            // Обновляем список для генерации
            const genChannelList = document.getElementById('generationChannelList');
            if (genChannelList) {
                genChannelList.innerHTML = '';
                
                channels.forEach(channel => {
                    const card = document.createElement('div');
                    card.className = 'channel-card';
                    card.onclick = () => toggleChannelSelection(channel.id);
                    card.innerHTML = `
                        <div class="channel-name">${channel.name}</div>
                        <div class="channel-info">${channel.export.resolution} • ${channel.export.codec}</div>
                        <div class="tags-container">
                            ${channel.effects && channel.effects.kenBurns && channel.effects.kenBurns.length > 0 ? '<span class="tag">Ken Burns</span>' : ''}
                            ${channel.effects && channel.effects.capcutEffects && channel.effects.capcutEffects.length > 0 ? '<span class="tag">CapCut FX</span>' : ''}
                            ${channel.overlays && channel.overlays.enabled ? '<span class="tag">Оверлеи</span>' : ''}
                            ${channel.effects && channel.effects.enable3D ? '<span class="tag">3D</span>' : ''}
                        </div>
                    `;
                    if (selectedChannels.has(channel.id)) {
                        card.classList.add('selected');
                    }
                    genChannelList.appendChild(card);
                });
            } else {
                console.error('Элемент generationChannelList не найден');
            }
            
            // Обновляем селекторы
            updateChannelSelectors();
        }

        function updateChannelSelectors() {
            const selectors = [
                'channelSelector',
                'overlayChannelSelector', 
                'capcutChannelSelector'
            ];
            
            selectors.forEach(selectorId => {
                const selector = document.getElementById(selectorId);
                if (selector) {
                    const currentValue = selector.value;
                    selector.innerHTML = '<option value="">Выберите канал...</option>';
                    
                    channels.forEach(channel => {
                        const option = document.createElement('option');
                        option.value = channel.id;
                        option.textContent = channel.name;
                        selector.appendChild(option);
                    });
                    
                    selector.value = currentValue;
                }
            });
        }

        function toggleChannelSelection(channelId) {
            if (selectedChannels.has(channelId)) {
                selectedChannels.delete(channelId);
            } else {
                selectedChannels.add(channelId);
            }
            updateChannelLists();
        }

        function selectAllChannels() {
            channels.forEach(channel => selectedChannels.add(channel.id));
            updateChannelLists();
        }

        function deselectAllChannels() {
            selectedChannels.clear();
            updateChannelLists();
        }

        // === СОЗДАНИЕ И УПРАВЛЕНИЕ КАНАЛАМИ ===

        function createChannel() {
            document.getElementById('channelModal').classList.add('show');
        }

        function saveNewChannel() {
            const name = document.getElementById('newChannelName').value.trim();
            const description = document.getElementById('newChannelDescription').value.trim();
            const template = document.getElementById('newChannelTemplate').value;
            
            if (!name) {
                alert('Введите название канала!');
                return;
            }
            
            // Базовые настройки в зависимости от шаблона
            const templateSettings = {
                youtube: { resolution: '1920x1080', fps: 30, bitrate: 8 },
                shorts: { resolution: '1080x1920', fps: 30, bitrate: 10 },
                square: { resolution: '1080x1080', fps: 30, bitrate: 6 },
                custom: { resolution: 'custom', fps: 30, bitrate: 8 }
            };
            
            const settings = templateSettings[template] || templateSettings.youtube;
            
            const newChannel = {
                id: 'channel_' + Date.now(),
                name: name,
                description: description,
                template: template,
                export: {
                    resolution: settings.resolution,
                    customWidth: 1920,
                    customHeight: 1080,
                    fps: settings.fps,
                    bitrate: settings.bitrate,
                    codec: 'h264'
                },
                effects: {
                    kenBurns: [],
                    kenBurnsIntensity: 30,
                    rotationAngle: 5,
                    smartCrop: true,
                    kbRandomize: false,
                    transitions: ['fade'],
                    transitionDuration: 1.0,
                    transRandomize: false,
                    colorCorrection: false,
                    colorFilter: 'none',
                    vignette: false,
                    vignetteIntensity: 40,
                    grain: false,
                    grainIntensity: 20,
                    audioPitch: '0',
                    audioEffect: 'none',
                    audioStereoEnhance: false,
                    audioNormalize: true,
                    easingType: 'ease',
                    bezierP1: 25,
                    bezierP2: 75,
                    enable3D: false,
                    type3D: 'basic',
                    intensity3D: 20,
                    autoRotate3D: false,
                    capcutEffects: [],
                    scaleAmplitude: 15,
                    zoomBurstStart: 150,
                    zoomBurstDecay: 80,
                    motionEffects: [],
                    motionIntensity: 30,
                    effectFrequency: 'all',
                    effectPercent: 50,
                    effectEvery: 3,
                    avoidRepetition: true
                },
                overlays: {
                    enabled: false,
                    files: [],
                    blendMode: 'screen',
                    opacity: 100,
                    randomize: false,
                    stretch: true
                }
            };
            
            channels.push(newChannel);
            saveChannels();
            updateChannelLists();
            closeModal('channelModal');
            
            // Очищаем поля формы
            document.getElementById('newChannelName').value = '';
            document.getElementById('newChannelDescription').value = '';
            document.getElementById('newChannelTemplate').value = 'youtube';
            
            log(`Создан новый канал: ${name}`, 'info');
        }

        function createChannelFromTemplate() {
            document.getElementById('templateModal').classList.add('show');
        }

        function createFromTemplate(templateType) {
            const templates = {
                dynamic: {
                    name: 'Динамичный канал',
                    description: 'Много движения и эффектов',
                    kenBurns: ['zoomIn', 'zoomOut', 'panLeft', 'panRight', 'rotate'],
                    kenBurnsIntensity: 50,
                    transitions: ['zoom', 'slide', 'push'],
                    transitionDuration: 0.5,
                    capcutEffects: ['zoomBurst', 'bounce', 'shake'],
                    effectFrequency: 'percent',
                    effectPercent: 50
                },
                cinematic: {
                    name: 'Кинематографичный канал',
                    description: 'Плавные движения, атмосферная обработка',
                    kenBurns: ['zoomIn', 'panRight'],
                    kenBurnsIntensity: 30,
                    transitions: ['fade', 'dissolve'],
                    transitionDuration: 2.0,
                    colorCorrection: true,
                    colorFilter: 'cinematic',
                    vignette: true,
                    vignetteIntensity: 60,
                    grain: true,
                    grainIntensity: 15
                },
                minimal: {
                    name: 'Минималистичный канал',
                    description: 'Простые переходы без лишних эффектов',
                    kenBurns: [],
                    transitions: ['fade'],
                    transitionDuration: 1.0,
                    colorCorrection: false
                },
                retro: {
                    name: 'Ретро канал',
                    description: 'Винтажный стиль с эффектами старой пленки',
                    kenBurns: ['zoomOut', 'panLeft'],
                    kenBurnsIntensity: 20,
                    transitions: ['dip_black', 'dip_white'],
                    transitionDuration: 1.5,
                    colorCorrection: true,
                    colorFilter: 'vintage',
                    vignette: true,
                    vignetteIntensity: 80,
                    grain: true,
                    grainIntensity: 40,
                    audioPitch: '-1',
                    audioEffect: 'vintage'
                }
            };
            
            const template = templates[templateType];
            if (!template) return;
            
            const newChannel = {
                id: 'channel_' + Date.now(),
                name: template.name,
                description: template.description,
                template: 'youtube',
                export: {
                    resolution: '1920x1080',
                    customWidth: 1920,
                    customHeight: 1080,
                    fps: 30,
                    bitrate: 8,
                    codec: 'h264'
                },
                effects: {
                    kenBurns: template.kenBurns || [],
                    kenBurnsIntensity: template.kenBurnsIntensity || 30,
                    rotationAngle: 5,
                    smartCrop: true,
                    kbRandomize: false,
                    transitions: template.transitions || ['fade'],
                    transitionDuration: template.transitionDuration || 1.0,
                    transRandomize: false,
                    colorCorrection: template.colorCorrection || false,
                    colorFilter: template.colorFilter || 'none',
                    vignette: template.vignette || false,
                    vignetteIntensity: template.vignetteIntensity || 40,
                    grain: template.grain || false,
                    grainIntensity: template.grainIntensity || 20,
                    audioPitch: template.audioPitch || '0',
                    audioEffect: template.audioEffect || 'none',
                    audioStereoEnhance: false,
                    audioNormalize: true,
                    easingType: 'ease',
                    bezierP1: 25,
                    bezierP2: 75,
                    enable3D: false,
                    type3D: 'basic',
                    intensity3D: 20,
                    autoRotate3D: false,
                    capcutEffects: template.capcutEffects || [],
                    scaleAmplitude: 15,
                    zoomBurstStart: 150,
                    zoomBurstDecay: 80,
                    motionEffects: [],
                    motionIntensity: 30,
                    effectFrequency: template.effectFrequency || 'all',
                    effectPercent: template.effectPercent || 50,
                    effectEvery: 3,
                    avoidRepetition: true
                },
                overlays: {
                    enabled: false,
                    files: [],
                    blendMode: 'screen',
                    opacity: 100,
                    randomize: false,
                    stretch: true
                }
            };
            
            channels.push(newChannel);
            saveChannels();
            updateChannelLists();
            closeModal('templateModal');
            log(`Создан канал из шаблона: ${template.name}`, 'info');
        }

        function editChannel(channelId) {
            document.querySelector('[data-tab="effects"]').click();
            document.getElementById('channelSelector').value = channelId;
            loadChannelEffects();
        }

        function duplicateChannel(channelId) {
            const channel = channels.find(c => c.id === channelId);
            if (!channel) return;
            
            const newChannel = JSON.parse(JSON.stringify(channel));
            newChannel.id = 'channel_' + Date.now();
            newChannel.name = channel.name + ' (копия)';
            
            channels.push(newChannel);
            saveChannels();
            updateChannelLists();
            log(`Канал "${channel.name}" дублирован`, 'info');
        }

        function deleteChannel(channelId) {
            const channel = channels.find(c => c.id === channelId);
            if (!channel) return;
            
            if (confirm(`Удалить канал "${channel.name}"?`)) {
                channels = channels.filter(c => c.id !== channelId);
                saveChannels();
                updateChannelLists();
                log(`Канал "${channel.name}" удален`, 'info');
            }
        }

        function exportChannels() {
            const dataStr = JSON.stringify(channels, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = 'automontage_channels_' + new Date().toISOString().slice(0, 10) + '.json';
            link.click();
            
            log('Каналы экспортированы', 'info');
        }

        function importChannels() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const imported = JSON.parse(event.target.result);
                        if (Array.isArray(imported)) {
                            channels = channels.concat(imported);
                            saveChannels();
                            updateChannelLists();
                            log(`Импортировано каналов: ${imported.length}`, 'info');
                        } else {
                            alert('Неверный формат файла');
                        }
                    } catch (err) {
                        alert('Ошибка импорта: ' + err.message);
                        log('Ошибка импорта каналов', 'error');
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
        }

        // === ГЕНЕРАЦИЯ МОНТАЖА ===

        function testMontage() {
            if (!PROJECT_FOLDER) {
                alert("Сначала выберите папку проекта!");
                return;
            }
            
            log('Запуск тестовой генерации (1 пара файлов)', 'info');
            
            // Создаем временный канал для теста
            const testChannel = {
                id: 'test_channel',
                name: 'Тестовый канал',
                export: {
                    resolution: '1920x1080',
                    fps: 30,
                    bitrate: 8,
                    codec: 'h264'
                },
                effects: {
                    kenBurns: ['zoomIn'],
                    kenBurnsIntensity: 30,
                    transitions: ['fade'],
                    transitionDuration: 1.0,
                    audioPitch: '0',
                    audioEffect: 'none',
                    audioNormalize: true
                }
            };
            
            selectedChannels.clear();
            selectedChannels.add('test_channel');
            
            generateMontage(true);
        }

        function importFiles() {
            if (!PROJECT_FOLDER) {
                alert("Сначала выберите папку проекта!");
                return;
            }
            
            updateProgress(0, "Импорт файлов...");
            log("Начинаем импорт файлов в проект", 'info');
            
            const includeVideos = document.getElementById('includeVideos').checked;
            
            const extScript = `
                function importProjectFiles(folderPath, includeVideos) {
                    try {
                        var project = app.project;
                        if (!project) return "ERROR: Нет активного проекта";
                        
                        var folder = new Folder(folderPath);
                        if (!folder.exists) return "ERROR: Папка не существует";
                        
                        var importBin = project.rootItem.createBin("Auto Montage Import " + new Date().toLocaleString());
                        var files = folder.getFiles();
                        var importedCount = 0;
                        
                        var supportedImageFormats = ['.jpg', '.jpeg', '.png', '.tiff', '.bmp'];
                        var supportedVideoFormats = ['.mp4', '.mov', '.avi', '.mkv'];
                        var supportedAudioFormats = ['.mp3', '.wav', '.aiff', '.m4a', '.flac'];
                        
                        var filesToImport = [];
                        
                        for (var i = 0; i < files.length; i++) {
                            if (files[i] instanceof File) {
                                var ext = files[i].name.substr(files[i].name.lastIndexOf('.')).toLowerCase();
                                
                                if (supportedImageFormats.indexOf(ext) > -1 || 
                                    supportedAudioFormats.indexOf(ext) > -1 ||
                                    (includeVideos && supportedVideoFormats.indexOf(ext) > -1)) {
                                    filesToImport.push(files[i].fsName);
                                    importedCount++;
                                }
                            }
                        }
                        
                        if (filesToImport.length > 0) {
                            project.importFiles(filesToImport, false, importBin, false);
                        }
                        
                        return "SUCCESS: Импортировано " + importedCount + " файлов";
                        
                    } catch(e) {
                        return "ERROR: " + e.toString();
                    }
                }
                
                importProjectFiles("${PROJECT_FOLDER.replace(/\\/g, '\\\\')}", ${includeVideos});
            `;
            
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                csInterface.evalScript(extScript, function(result) {
                    if (result.indexOf("SUCCESS") === 0) {
                        updateProgress(100, "Файлы импортированы");
                        log(result, 'info');
                    } else {
                        updateProgress(0, "Ошибка импорта");
                        log(result, 'error');
                    }
                });
            } else {
                setTimeout(() => {
                    updateProgress(100, "Файлы импортированы (симуляция)");
                    log("Импортировано 15 файлов (симуляция)", 'info');
                }, 1500);
            }
        }

        async function generateMontage(testMode = false) {
            if (!PROJECT_FOLDER) {
                alert("Сначала выберите папку проекта!");
                return;
            }
            
            if (!testMode && selectedChannels.size === 0) {
                alert("Выберите хотя бы один канал для генерации!");
                return;
            }
            
            // Проверяем результат сканирования
            if (!window.lastScanResult || !window.lastScanResult.pairs || window.lastScanResult.pairs.length === 0) {
                alert("Не найдено пар файлов для монтажа! Проверьте нумерацию файлов (0001, 0002...)");
                return;
            }
            
            isGenerating = true;
            generationAborted = false;
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('cancelButton').classList.add('show');
            
            const channelsToProcess = testMode ? 
                [{id: 'test_channel', name: 'Тест', export: {resolution: '1920x1080', fps: 30, bitrate: 8, codec: 'h264'}, effects: {}}] : 
                Array.from(selectedChannels).map(id => channels.find(c => c.id === id)).filter(Boolean);
            
            log(`Начинаем генерацию для ${channelsToProcess.length} каналов`, 'info');
            
            // Импортируем файлы в проект если есть CSInterface
            if (csInterface) {
                log('Импортируем файлы в проект перед генерацией...', 'info');
                await importFilesBeforeGeneration();
            }
            
            // Подготовка аудио файлов если нужно
            if (document.getElementById('processAudioFirst').checked) {
                await prepareAudioFiles(channelsToProcess);
                
                if (generationAborted) {
                    finishGeneration();
                    return;
                }
            }
            
            // Генерация для каждого канала
            let channelIndex = 0;
            for (const channel of channelsToProcess) {
                if (generationAborted) break;
                
                channelIndex++;
                updateProgress(
                    (channelIndex / channelsToProcess.length) * 100,
                    `Генерация для канала: ${channel.name}`
                );
                
                await generateChannelMontage(channel, testMode);
            }
            
            finishGeneration();
        }

        function finishGeneration() {
            isGenerating = false;
            document.getElementById('generateBtn').disabled = false;
            document.getElementById('cancelButton').classList.remove('show');
            updateProgress(100, generationAborted ? "Генерация отменена" : "Генерация завершена!");
            log(generationAborted ? "Генерация отменена пользователем" : "Генерация завершена успешно", 
                generationAborted ? 'warning' : 'info');
        }

        async function importFilesBeforeGeneration() {
            return new Promise((resolve) => {
                const includeVideos = document.getElementById('includeVideos').checked;
                
                const extScript = `
                    function importProjectFiles(folderPath, audioVariantsPath, includeVideos) {
                        try {
                            var project = app.project;
                            if (!project) return "ERROR: Нет активного проекта";
                            
                            var importBin = project.rootItem.createBin("Auto Montage Import " + new Date().toLocaleString());
                            var importedCount = 0;
                            
                            var supportedImageFormats = ['.jpg', '.jpeg', '.png', '.tiff', '.bmp'];
                            var supportedVideoFormats = ['.mp4', '.mov', '.avi', '.mkv'];
                            var supportedAudioFormats = ['.mp3', '.wav', '.aiff', '.m4a', '.flac'];
                            
                            var filesToImport = [];
                            
                            // Импортируем из основной папки
                            var folder = new Folder(folderPath);
                            if (folder.exists) {
                                var files = folder.getFiles();
                                for (var i = 0; i < files.length; i++) {
                                    if (files[i] instanceof File) {
                                        var ext = files[i].name.substr(files[i].name.lastIndexOf('.')).toLowerCase();
                                        
                                        if (supportedImageFormats.indexOf(ext) > -1 || 
                                            supportedAudioFormats.indexOf(ext) > -1 ||
                                            (includeVideos && supportedVideoFormats.indexOf(ext) > -1)) {
                                            filesToImport.push(files[i].fsName);
                                        }
                                    }
                                }
                            }
                            
                            // Импортируем из папки audio_variants
                            var audioVariantsFolder = new Folder(audioVariantsPath);
                            if (audioVariantsFolder.exists) {
                                var audioFiles = audioVariantsFolder.getFiles();
                                for (var j = 0; j < audioFiles.length; j++) {
                                    if (audioFiles[j] instanceof File) {
                                        var ext2 = audioFiles[j].name.substr(audioFiles[j].name.lastIndexOf('.')).toLowerCase();
                                        if (supportedAudioFormats.indexOf(ext2) > -1) {
                                            filesToImport.push(audioFiles[j].fsName);
                                        }
                                    }
                                }
                            }
                            
                            if (filesToImport.length > 0) {
                                project.importFiles(filesToImport, false, importBin, false);
                                importedCount = filesToImport.length;
                            }
                            
                            return "SUCCESS: Импортировано " + importedCount + " файлов";
                            
                        } catch(e) {
                            return "ERROR: " + e.toString();
                        }
                    }
                    
                    importProjectFiles("${PROJECT_FOLDER.replace(/\\/g, '\\\\')}", "${AUDIO_VARIANTS_FOLDER.replace(/\\/g, '\\\\')}", ${includeVideos});
                `;
                
                csInterface.evalScript(extScript, function(result) {
                    log(result, result.indexOf("SUCCESS") === 0 ? 'info' : 'error');
                    setTimeout(resolve, 1000); // Даем время на обработку импорта
                });
            });
        }

        async function prepareAudioFiles(channelsToProcess) {
            return new Promise((resolve) => {
                updateProgress(10, "Подготовка аудио файлов...");
                
                // Собираем уникальные настройки аудио
                const audioVariants = new Set();
                channelsToProcess.forEach(channel => {
                    const pitch = channel.effects.audioPitch || '0';
                    const effect = channel.effects.audioEffect || 'none';
                    audioVariants.add(`${pitch}_${effect}`);
                });
                
                log(`Необходимо создать ${audioVariants.size} аудио вариантов`, 'info');
                
                const transcodeRussian = document.getElementById('transcodeRussian').checked;
                
                const extScript = `
                    function prepareAudioVariants(folderPath, variants, transcodeRussian) {
                        try {
                            var variantsFolder = new Folder(folderPath + "/audio_variants");
                            if (!variantsFolder.exists) variantsFolder.create();
                            
                            // Создаем bat файл для обработки
                            var batContent = '@echo off\\n';
                            batContent += 'echo Starting audio processing...\\n';
                            batContent += 'cd /d "' + folderPath + '"\\n';
                            
                            // Находим все аудио файлы
                            var folder = new Folder(folderPath);
                            var audioFiles = [];
                            var files = folder.getFiles();
                            
                            for (var i = 0; i < files.length; i++) {
                                if (files[i] instanceof File) {
                                    var ext = files[i].name.substr(files[i].name.lastIndexOf('.')).toLowerCase();
                                    if (['.mp3', '.wav', '.m4a', '.flac'].indexOf(ext) > -1) {
                                        audioFiles.push(files[i]);
                                    }
                                }
                            }
                            
                            // Генерируем команды для каждого файла и варианта
                            for (var j = 0; j < audioFiles.length; j++) {
                                var audioFile = audioFiles[j];
                                var baseName = audioFile.name.substr(0, audioFile.name.lastIndexOf('.'));
                                
                                // Обработка русских имен если нужно
                                var inputName = audioFile.name;
                                var outputBaseName = baseName;
                                
                                if (transcodeRussian && /[а-яА-Я]/.test(inputName)) {
                                    // Транслитерация или использование номера
                                    var number = baseName.match(/^\\d+/);
                                    outputBaseName = number ? 'audio_' + number[0] : 'audio_' + j;
                                }
                                
                                for (var k = 0; k < variants.length; k++) {
                                    var parts = variants[k].split('_');
                                    var pitch = parts[0];
                                    var effect = parts[1];
                                    
                                    var outputName = outputBaseName + '_pitch_' + pitch.replace('+', 'plus').replace('.', '_');
                                    if (effect !== 'none') outputName += '_' + effect;
                                    outputName += '.mp3';
                                    
                                    // FFmpeg команда
                                    batContent += 'ffmpeg -i "' + inputName + '" ';
                                    
                                    // Создаем фильтры
                                    var filters = [];
                                    
                                    // Pitch
                                    if (pitch !== '0') {
                                        var semitones = parseFloat(pitch);
                                        var rate = Math.pow(2, semitones/12);
                                        filters.push('asetrate=44100*' + rate.toFixed(4) + ',aresample=44100');
                                    }
                                    
                                    // Эффекты
                                    if (effect === 'bass') {
                                        filters.push('bass=g=10');
                                    } else if (effect === 'reverb') {
                                        filters.push('aecho=0.8:0.9:40:0.4');
                                    } else if (effect === 'echo') {
                                        filters.push('aecho=0.8:0.7:60:0.5');
                                    }
                                    
                                    // Применяем фильтры
                                    if (filters.length > 0) {
                                        batContent += '-af "' + filters.join(',') + '" ';
                                    }
                                    
                                    batContent += '-b:a 192k "audio_variants/' + outputName + '" -y\\n';
                                }
                            }
                            
                            batContent += 'echo Audio processing completed\\n';
                            batContent += 'pause\\n';
                            
                            // Сохраняем и запускаем bat файл
                            var batFile = new File(folderPath + '/process_audio.bat');
                            batFile.open('w');
                            batFile.write(batContent);
                            batFile.close();
                            
                            // Запускаем
                            batFile.execute();
                            
                            return "SUCCESS: Bat файл создан и запущен";
                            
                        } catch(e) {
                            return "ERROR: " + e.toString();
                        }
                    }
                    
                    var variants = ${JSON.stringify(Array.from(audioVariants))};
                    prepareAudioVariants("${PROJECT_FOLDER.replace(/\\/g, '\\\\')}", variants, ${transcodeRussian});
                `;
                
                if (typeof CSInterface !== 'undefined') {
                    const csInterface = new CSInterface();
                    csInterface.evalScript(extScript, function(result) {
                        log(result, result.startsWith('SUCCESS') ? 'info' : 'error');
                        
                        // Ждем немного для обработки
                        setTimeout(resolve, 3000);
                    });
                } else {
                    setTimeout(() => {
                        log("Аудио файлы подготовлены (симуляция)", 'info');
                        resolve();
                    }, 2000);
                }
            });
        }

        async function generateChannelMontage(channel, testMode = false) {
            return new Promise((resolve) => {
                log(`Создание монтажа для канала: ${channel.name}`, 'info');
                
                const pairs = testMode ? 
                    window.lastScanResult.pairs.slice(0, 1) : // Только первая пара для теста
                    window.lastScanResult.pairs;
                
                const config = {
                    channelName: channel.name.replace(/[^a-zA-Z0-9]/g, '_'), // Безопасное имя
                    channelId: channel.id,
                    export: channel.export,
                    effects: channel.effects,
                    overlays: channel.overlays,
                    projectFolder: PROJECT_FOLDER,
                    audioVariantsFolder: AUDIO_VARIANTS_FOLDER,
                    pairs: pairs,
                    testMode: testMode
                };
                
                if (csInterface) {
                    log('🔧 Попытка создания реального монтажа через ExtendScript', 'info');
                    
                    const extScript = `
                        ${getMontageFunctions()}
                        
                        try {
                            // Проверка окружения
                            if (!app.project) {
                                throw new Error("Нет активного проекта в Premiere Pro");
                            }
                            
                            var config = ${JSON.stringify(config)};
                            var result = createChannelMontage(config);
                            JSON.stringify(result);
                        } catch(e) {
                            JSON.stringify({success: false, error: e.toString()});
                        }
                    `;
                    
                    csInterface.evalScript(extScript, function(result) {
                        log('📋 Ответ от ExtendScript: ' + (result ? result.substring(0, 100) : 'пусто'), 'info');
                        
                        try {
                            const response = JSON.parse(result);
                            if (response.success) {
                                log(`✅ Монтаж для канала "${channel.name}" создан успешно!`, 'info');
                                log(`Создана секвенция: ${response.sequenceName}`, 'info');
                                log(`Добавлено клипов: ${response.clipsAdded}`, 'info');
                            } else {
                                log(`❌ Ошибка создания монтажа: ${response.error}`, 'error');
                            }
                        } catch(e) {
                            log('❌ Ошибка парсинга результата: ' + e.message, 'error');
                            log('Полный ответ: ' + result, 'error');
                        }
                        resolve();
                    });
                } else {
                    log('⚠️ CSInterface не доступен, используем режим симуляции', 'warning');
                    setTimeout(() => {
                        log(`Монтаж для канала "${channel.name}" создан (симуляция)`, 'info');
                        resolve();
                    }, 3000);
                }
            });
        }

        function getMontageFunctions() {
            return `
                function createChannelMontage(config) {
                    var project = app.project;
                    if (!project) {
                        return {success: false, error: "Нет активного проекта"};
                    }
                    
                    try {
<<<<<<< HEAD
											
=======
>>>>>>> 5adb8a335390beae31960bdd51844c4147e887e1
                        // Создаем секвенцию
                        var sequenceName = "Montage_" + config.channelName + "_" + new Date().getTime();
                        
                        // Получаем правильный пресет
                        var presetPath = getSequencePreset(config.export);
                        var sequence = project.createNewSequence(sequenceName, presetPath);
                        
                        if (!sequence) {
                            return {success: false, error: "Не удалось создать секвенцию"};
                        }
                        
                        // Основная функция построения монтажа
                        var result = buildMontageSequence(sequence, config);
                        
                        if (!result.success) {
                            return result;
                        }
                        
                        return {
                            success: true, 
                            sequenceName: sequenceName,
                            clipsAdded: result.clipsAdded
                        };
                        
                    } catch(e) {
                        return {success: false, error: "createChannelMontage: " + e.toString()};
                    }
                }
                
                function getSequencePreset(exportSettings) {
                    // Возвращаем ID пресета в зависимости от настроек
                    if (exportSettings.resolution === '1920x1080') {
                        return ""; // Стандартный HD пресет
                    } else if (exportSettings.resolution === '3840x2160') {
                        return ""; // 4K пресет
                    } else if (exportSettings.resolution === '1080x1920') {
                        return ""; // Вертикальный пресет
                    }
                    return ""; // По умолчанию
                }
                
<<<<<<< HEAD
				function buildMontageSequence(sequence, config) {
					try {
						alert("Effects: " + (config.effects ? "есть" : "нет") + 
                              ", kenBurns: " + (config.effects && config.effects.kenBurns ? config.effects.kenBurns.length : "0"));
						$.writeln("=== НАЧАЛО buildMontageSequence ===");
						
						var videoTrack1 = sequence.videoTracks[0];
						var audioTrack1 = sequence.audioTracks[0];
						
						if (!videoTrack1 || !audioTrack1) {
							return {success: false, error: "Нет треков"};
						$.writeln("=== ОТЛАДКА НАСТРОЕК ===");
						try {
							$.writeln("config передан: " + (config ? "ДА" : "НЕТ"));
							if (config) {
								$.writeln("config.effects: " + (config.effects ? "ЕСТЬ" : "НЕТ"));
								if (config.effects) {
									$.writeln("kenBurns настройки: " + (config.effects.kenBurns ? config.effects.kenBurns.length + " эффектов" : "НЕТ"));
									$.writeln("transitions настройки: " + (config.effects.transitions ? config.effects.transitions.length + " переходов" : "НЕТ"));
									$.writeln("colorCorrection: " + config.effects.colorCorrection);
								}
							}
						} catch(e) {
							$.writeln("Ошибка отладки: " + e.toString());
						}
						$.writeln("=========================");
						if (config.effects) {
							$.writeln("config.effects существует");
							$.writeln("kenBurns: " + JSON.stringify(config.effects.kenBurns));
							$.writeln("transitions: " + JSON.stringify(config.effects.transitions));
						} else {
							$.writeln("config.effects ОТСУТСТВУЕТ!");
						}
						$.writeln("=========================");							
						}
						
						$.writeln("Количество пар: " + config.pairs.length);
						
						var currentTime = 0;
						var clipsAdded = 0;
						var previousVideoClip = null;
						
						for (var i = 0; i < config.pairs.length; i++) {
							var pair = config.pairs[i];
							$.writeln("=== Пара " + (i+1) + " ===");
							
							var mediaItem = findProjectItem(pair.mediaFile.name);
							var audioItem = findProjectItem(pair.audioFile.name);
							
							if (!mediaItem || !audioItem) {
								$.writeln("Файлы не найдены, пропускаем");
								continue;
							}
							
							$.writeln("Добавляем клипы в позицию: " + currentTime);
							
							// Добавляем аудио первым
							audioTrack1.insertClip(audioItem, currentTime);
							var audioClip = audioTrack1.clips[audioTrack1.clips.numItems - 1];
							
							if (!audioClip) {
								$.writeln("Не удалось добавить аудио клип");
								continue;
							}
							
							var audioDuration = audioClip.duration.seconds;
							$.writeln("Длительность аудио: " + audioDuration);
							
							// НОВЫЙ ПОДХОД: устанавливаем In/Out точки ПЕРЕД добавлением видео
							try {
								// Устанавливаем In/Out точки ПЕРЕД добавлением
								mediaItem.setInPoint(0, 4);
								mediaItem.setOutPoint(audioDuration, 4);
								
								// Добавляем видео с установленными точками
								videoTrack1.insertClip(mediaItem, currentTime);
								var videoClip = videoTrack1.clips[videoTrack1.clips.numItems - 1];
								
								if (videoClip) {
									$.writeln("Видео клип добавлен с длительностью: " + videoClip.duration.seconds);
									
									// Исправляем масштаб если он нулевой
									try {
										for (var c = 0; c < videoClip.components.numItems; c++) {
											if (videoClip.components[c].displayName === "Motion") {
												var scaleParam = videoClip.components[c].properties[0];
												if (scaleParam && scaleParam.getValue() === 0) {
													scaleParam.setValue(100);
													$.writeln("Исправлен нулевой масштаб для клипа " + (i+1));
												}
												break;
											}
										}
									} catch(e) {
										$.writeln("Ошибка исправления масштаба: " + e.toString());
									}
									
									// Добавляем переход если есть предыдущий клип
									if (previousVideoClip && config.effects && config.effects.transitions && config.effects.transitions.length > 0) {
										try {
											addTransition(previousVideoClip, videoClip, config.effects);
											$.writeln("Переход добавлен между клипами " + i + " и " + (i+1));
										} catch(e) {
											$.writeln("Ошибка добавления перехода: " + e.toString());
										}
									}
									
									previousVideoClip = videoClip;
								
								
							} else {
								$.writeln("Не удалось добавить видео клип");
							}
								
							} catch(e) {
								$.writeln("Ошибка установки In/Out: " + e.toString());
								
								// Fallback - добавляем как есть
								// videoTrack1.insertClip(mediaItem, currentTime);
								var fallbackVideoClip = videoTrack1.clips[videoTrack1.clips.numItems - 1];
								
								if (fallbackVideoClip) {
									$.writeln("Добавлен без установки длительности");
									
									// Применяем эффекты и к fallback клипу
									try {
										if (config.effects) {
											applyClipEffects(fallbackVideoClip, config.effects, i);
											$.writeln("Эффекты применены к fallback клипу " + (i+1));
										}
									} catch(e) {
										$.writeln("Ошибка применения эффектов к fallback: " + e.toString());
									}
									
									// Добавляем переход
									if (previousVideoClip && config.effects && config.effects.transitions && config.effects.transitions.length > 0) {
										try {
											addTransition(previousVideoClip, fallbackVideoClip, config.effects);
											$.writeln("Переход добавлен для fallback клипа");
										} catch(e) {
											$.writeln("Ошибка добавления перехода для fallback: " + e.toString());
										}
									}
									
									previousVideoClip = fallbackVideoClip;
								}
							}
							
							currentTime += audioDuration;
							clipsAdded += 2;
							
							$.writeln("Пара добавлена. Следующая позиция: " + currentTime);
						}
						
						// Добавляем оверлеи если настроены
						if (config.overlays && config.overlays.enabled && config.overlays.files && config.overlays.files.length > 0) {
							try {
								$.writeln("Добавляем оверлеи...");
								addOverlays(sequence, config.overlays, currentTime);
								$.writeln("Оверлеи добавлены");
							} catch(e) {
								$.writeln("Ошибка добавления оверлеев: " + e.toString());
							}
						}
						
						$.writeln("ИТОГО: " + clipsAdded + " клипов");
						$.writeln("=== КОНЕЦ buildMontageSequence ===");
						
						return {success: true, clipsAdded: clipsAdded, totalDuration: currentTime};
						
					} catch(e) {
						$.writeln("ОШИБКА: " + e.toString());
						return {success: false, error: e.toString()};
					}
				}                
=======
                function buildMontageSequence(sequence, config) {
                    try {
                        var videoTrack = sequence.videoTracks[0];
                        var audioTrack = sequence.audioTracks[0];
                        
                        if (!videoTrack || !audioTrack) {
                            return {success: false, error: "Не удалось получить доступ к трекам"};
                        }
                        
                        var currentTime = 0;
                        var clipsAdded = 0;
                        var previousClip = null;
                        
                        // Обрабатываем каждую пару файлов
                        for (var i = 0; i < config.pairs.length; i++) {
                            var pair = config.pairs[i];
                            
                            // Находим медиа файл в проекте
                            var mediaItem = findProjectItem(pair.mediaFile.name);
                            var audioItem = findAudioVariant(pair.audioFile.name, config);
                            
                            if (!mediaItem || !audioItem) {
                                $.writeln("Пропускаем пару " + pair.number + ": файлы не найдены в проекте");
                                continue;
                            }
                            
                            // Добавляем на таймлайн
                            var videoClip = videoTrack.insertClip(mediaItem, currentTime);
                            var audioClip = audioTrack.insertClip(audioItem, currentTime);
                            
                            if (!videoClip || !audioClip) {
                                continue;
                            }
                            
                            // Синхронизируем длительность
                            var audioDuration = audioClip.duration.seconds;
                            
                            // Для видео файлов - обрабатываем зацикливание
                            if (pair.mediaType === 'video' && videoClip.duration.seconds < audioDuration) {
                                handleVideoLooping(videoClip, audioDuration, videoTrack, currentTime);
                            } else {
                                // Для изображений или длинных видео - просто устанавливаем длительность
                                videoClip.end = videoClip.start + audioDuration;
                            }
                            
                            // Применяем эффекты
                            applyClipEffects(videoClip, config, i);
                            
                            // Добавляем переход если есть предыдущий клип
                            if (previousClip && config.effects.transitions && config.effects.transitions.length > 0) {
                                addTransition(previousClip, videoClip, config.effects);
                            }
                            
                            previousClip = videoClip;
                            currentTime += audioDuration;
                            clipsAdded++;
                        }
                        
                        // Добавляем оверлеи если нужно
                        if (config.overlays && config.overlays.enabled && config.overlays.files.length > 0) {
                            addOverlays(sequence, config.overlays, currentTime);
                        }
                        
                        return {success: true, clipsAdded: clipsAdded};
                        
                    } catch(e) {
                        return {success: false, error: "buildMontageSequence: " + e.toString()};
                    }
                }
                
>>>>>>> 5adb8a335390beae31960bdd51844c4147e887e1
                function findProjectItem(fileName) {
                    // Рекурсивный поиск элемента в проекте
                    function searchInBin(bin, name) {
                        for (var i = 0; i < bin.children.numItems; i++) {
                            var item = bin.children[i];
                            if (item.type === ProjectItemType.BIN) {
                                var found = searchInBin(item, name);
                                if (found) return found;
                            } else if (item.name === name) {
                                return item;
                            }
                        }
                        return null;
                    }
                    
                    return searchInBin(app.project.rootItem, fileName);
                }
                
                function findAudioVariant(originalName, config) {
                    // Сначала ищем обработанный вариант
                    var baseName = originalName.substr(0, originalName.lastIndexOf('.'));
                    var pitch = config.effects.audioPitch || '0';
                    var effect = config.effects.audioEffect || 'none';
                    
                    var variantName = baseName + '_pitch_' + pitch.replace('+', 'plus').replace('.', '_');
                    if (effect !== 'none') variantName += '_' + effect;
                    variantName += '.mp3';
                    
                    var variant = findProjectItem(variantName);
                    if (variant) return variant;
                    
                    // Если не нашли - возвращаем оригинал
                    return findProjectItem(originalName);
                }
                
                function handleVideoLooping(videoClip, targetDuration, videoTrack, startTime) {
                    var clipDuration = videoClip.duration.seconds;
                    var currentTime = startTime;
                    var sourceItem = videoClip.projectItem;
<<<<<<< HEAD
						// Сбрасываем In/Out для зацикливания
						try {
							sourceItem.clearInPoint();
							sourceItem.clearOutPoint();
						} catch(e) {}					
=======
>>>>>>> 5adb8a335390beae31960bdd51844c4147e887e1
                    
                    // Устанавливаем длительность первого клипа
                    videoClip.end = videoClip.start + Math.min(clipDuration, targetDuration);
                    currentTime += clipDuration;
                    
                    // Добавляем копии пока не достигнем нужной длительности
                    while (currentTime < startTime + targetDuration) {
                        var remainingTime = (startTime + targetDuration) - currentTime;
                        var nextClip = videoTrack.insertClip(sourceItem, currentTime);
                        
                        if (nextClip) {
                            if (remainingTime < clipDuration) {
                                // Обрезаем последний клип
                                nextClip.end = nextClip.start + remainingTime;
                            }
                            
                            // Добавляем плавный переход
                            var transition = videoTrack.getTransitionByName("Cross Dissolve");
                            if (transition) {
                                var transitionDuration = 0.5; // 0.5 секунды
                                videoTrack.insertTransition(transition, currentTime - transitionDuration/2);
                            }
                            
                            currentTime += Math.min(clipDuration, remainingTime);
                        } else {
                            break;
                        }
                    }
                }
                
<<<<<<< HEAD
				function applyClipEffects(clip, effects, clipIndex) {
					try {
						$.writeln("=== НАЧАЛО applyClipEffects для клипа " + (clipIndex + 1) + " ===");
						
						if (!clip) {
							$.writeln("Клип не найден");
							return;
						}
						
						// Применяем Ken Burns эффекты (используют встроенный Motion)
						if (effects.kenBurns && effects.kenBurns.length > 0) {
							applyKenBurnsEffect(clip, effects, clipIndex);
						}
						
						// Применяем CapCut эффекты (если они настроены)
						if (effects.capcutEffects && effects.capcutEffects.length > 0) {
							applyCapcutEffects(clip, effects, clipIndex);
						}
						
						// Применяем цветокоррекцию через QE API
						if (effects.colorCorrection) {
							applyColorCorrectionQE(clip, effects);
						}
						
						$.writeln("=== КОНЕЦ applyClipEffects ===");
						
					} catch(e) {
						$.writeln("ОШИБКА в applyClipEffects: " + e.toString());
					}
				}

				function applyKenBurnsEffect(clip, effects, clipIndex) {
					try {
						$.writeln("=== ДИАГНОСТИКА KEN BURNS ===");
						
						// Проверяем clip
						$.writeln("Clip существует: " + (clip ? "ДА" : "НЕТ"));
						if (!clip) return;
						
						$.writeln("Количество компонентов: " + clip.components.numItems);
						
						// Перебираем все компоненты
						for (var i = 0; i < clip.components.numItems; i++) {
							var comp = clip.components[i];
							$.writeln("Компонент[" + i + "]: " + comp.displayName);
						}
						
						// Проверяем Motion компонент
						var motionComponent = clip.components[1];
						if (motionComponent) {
							$.writeln("Motion найден: " + motionComponent.displayName);
							$.writeln("Количество properties: " + motionComponent.properties.numItems);
							
							// Перебираем все свойства Motion
							for (var p = 0; p < motionComponent.properties.numItems; p++) {
								var prop = motionComponent.properties[p];
								$.writeln("Property[" + p + "]: " + prop.displayName);
								
								// Проверяем доступные методы
								$.writeln("  - isTimeVarying: " + (typeof prop.isTimeVarying === 'function' ? "ЕСТЬ" : "НЕТ"));
								$.writeln("  - setTimeVarying: " + (typeof prop.setTimeVarying === 'function' ? "ЕСТЬ" : "НЕТ"));
								$.writeln("  - addKey: " + (typeof prop.addKey === 'function' ? "ЕСТЬ" : "НЕТ"));
								$.writeln("  - setValueAtKey: " + (typeof prop.setValueAtKey === 'function' ? "ЕСТЬ" : "НЕТ"));
								$.writeln("  - setValue: " + (typeof prop.setValue === 'function' ? "ЕСТЬ" : "НЕТ"));
								$.writeln("  - getValue: " + (typeof prop.getValue === 'function' ? "ЕСТЬ" : "НЕТ"));
							}
						} else {
							$.writeln("Motion компонент НЕ НАЙДЕН на позиции 1");
						}
						
					} catch(e) {
						$.writeln("ОШИБКА в диагностике: " + e.toString());
					}
				}

				function applyEasingToMotion(motionComponent, easingType) {
					try {
						// Применяем сглаживание к анимации
						// В Premiere Pro это делается через настройки интерполяции ключевых кадров
						$.writeln("Применяем интерполяцию: " + easingType);
						
						// Базовая реализация - в реальном API может потребоваться другой подход
						for (var i = 0; i < motionComponent.properties.numItems; i++) {
							var property = motionComponent.properties[i];
							if (property.isTimeVarying && property.getKeys) {
								var keys = property.getKeys();
								for (var k = 0; k < keys.length; k++) {
									// Здесь можно настроить тип интерполяции
									// Конкретная реализация зависит от API
								}
							}
						}
						
					} catch(e) {
						$.writeln("ОШИБКА в applyEasingToMotion: " + e.toString());
					}
				}

				function applyColorCorrectionQE(clip, effects) {
					try {
						$.writeln("Применяем цветокоррекцию через QE API");
						
						// Включаем QE API
						app.enableQE();
						
						// Получаем QE объект клипа
						var sequence = qe.project.getActiveSequence();
						var trackIndex = 0; // Нужно определить правильный трек
						var clipIndex = 0;  // Нужно определить правильный индекс клипа
						
						// Это требует дополнительной работы для поиска правильного QE клипа
						// Пока оставим заглушку
						$.writeln("Цветокоррекция через QE API - требует доработки");
						
					} catch(e) {
						$.writeln("ОШИБКА в applyColorCorrectionQE: " + e.toString());
					}
				}
               
=======
                function applyClipEffects(clip, config, clipIndex) {
                    if (!clip || !clip.isValid()) return;
                    
                    var effects = config.effects;
                    
                    // Ken Burns эффекты
                    if (effects.kenBurns && effects.kenBurns.length > 0) {
                        applyKenBurns(clip, effects, clipIndex);
                    }
                    
                    // CapCut эффекты
                    if (effects.capcutEffects && effects.capcutEffects.length > 0) {
                        applyCapcutEffects(clip, effects, clipIndex);
                    }
                    
                    // Цветокоррекция
                    if (effects.colorCorrection) {
                        applyColorCorrection(clip, effects);
                    }
                    
                    // 3D эффекты
                    if (effects.enable3D) {
                        apply3DEffects(clip, effects);
                    }
                }
                
                function applyKenBurns(clip, effects, clipIndex) {
                    var motionEffect = null;
                    
                    // Ищем Motion эффект
                    for (var i = 0; i < clip.components.numItems; i++) {
                        if (clip.components[i].displayName === "Motion") {
                            motionEffect = clip.components[i];
                            break;
                        }
                    }
                    
                    if (!motionEffect) return;
                    
                    // Выбираем эффект
                    var selectedEffect = effects.kbRandomize ? 
                        effects.kenBurns[Math.floor(Math.random() * effects.kenBurns.length)] :
                        effects.kenBurns[clipIndex % effects.kenBurns.length];
                    
                    var intensity = effects.kenBurnsIntensity / 100;
                    var startTime = clip.inPoint.seconds;
                    var endTime = clip.outPoint.seconds;
                    
                    // Получаем параметры
                    var scaleParam = motionEffect.properties.getParamForDisplayName("Scale");
                    var positionParam = motionEffect.properties.getParamForDisplayName("Position");
                    var rotationParam = motionEffect.properties.getParamForDisplayName("Rotation");
                    
                    // Умная обрезка - увеличиваем начальный масштаб для компенсации
                    var cropCompensation = effects.smartCrop ? 1.1 : 1.0;
                    
                    switch(selectedEffect) {
                        case 'zoomIn':
                            if (scaleParam) {
                                scaleParam.addKey(startTime);
                                scaleParam.setValueAtKey(startTime, 100 * cropCompensation);
                                scaleParam.addKey(endTime);
                                scaleParam.setValueAtKey(endTime, (100 + 30 * intensity) * cropCompensation);
                            }
                            break;
                            
                        case 'zoomOut':
                            if (scaleParam) {
                                scaleParam.addKey(startTime);
                                scaleParam.setValueAtKey(startTime, (100 + 30 * intensity) * cropCompensation);
                                scaleParam.addKey(endTime);
                                scaleParam.setValueAtKey(endTime, 100 * cropCompensation);
                            }
                            break;
                            
                        case 'panLeft':
                        case 'panRight':
                        case 'panUp':
                        case 'panDown':
                            if (positionParam && scaleParam) {
                                // Увеличиваем масштаб для умной обрезки
                                scaleParam.setValue(110 * cropCompensation);
                                
                                var direction = selectedEffect.replace('pan', '').toLowerCase();
                                var moveAmount = 0.1 * intensity;
                                
                                positionParam.addKey(startTime);
                                positionParam.addKey(endTime);
                                
                                var startPos = [0.5, 0.5];
                                var endPos = [0.5, 0.5];
                                
                                if (direction === 'left') endPos[0] -= moveAmount;
                                else if (direction === 'right') endPos[0] += moveAmount;
                                else if (direction === 'up') endPos[1] -= moveAmount;
                                else if (direction === 'down') endPos[1] += moveAmount;
                                
                                positionParam.setValueAtKey(startTime, startPos);
                                positionParam.setValueAtKey(endTime, endPos);
                            }
                            break;
                            
                        case 'rotate':
                            if (rotationParam && scaleParam) {
                                // Увеличиваем масштаб еще больше для компенсации углов
                                var rotationScale = 1 + (effects.rotationAngle / 90);
                                scaleParam.setValue(100 * cropCompensation * rotationScale);
                                
                                rotationParam.addKey(startTime);
                                rotationParam.setValueAtKey(startTime, -effects.rotationAngle / 2);
                                rotationParam.addKey(endTime);
                                rotationParam.setValueAtKey(endTime, effects.rotationAngle / 2);
                            }
                            break;
                            
                        case 'diagonal':
                            if (positionParam && scaleParam) {
                                scaleParam.setValue(120 * cropCompensation);
                                
                                positionParam.addKey(startTime);
                                positionParam.setValueAtKey(startTime, [0.4, 0.4]);
                                positionParam.addKey(endTime);
                                positionParam.setValueAtKey(endTime, [0.6, 0.6]);
                            }
                            break;
                    }
                    
                    // Применяем интерполяцию
                    applyEasing(motionEffect, effects.easingType, effects.bezierP1, effects.bezierP2);
                }
                
                function applyCapcutEffects(clip, effects, clipIndex) {
                    // Проверяем нужно ли применять эффект к этому клипу
                    if (!shouldApplyEffect(clipIndex, effects)) return;
                    
                    var motionEffect = null;
                    for (var i = 0; i < clip.components.numItems; i++) {
                        if (clip.components[i].displayName === "Motion") {
                            motionEffect = clip.components[i];
                            break;
                        }
                    }
                    
                    if (!motionEffect) return;
                    
                    var scaleParam = motionEffect.properties.getParamForDisplayName("Scale");
                    var positionParam = motionEffect.properties.getParamForDisplayName("Position");
                    var rotationParam = motionEffect.properties.getParamForDisplayName("Rotation");
                    
                    var startTime = clip.inPoint.seconds;
                    var endTime = clip.outPoint.seconds;
                    var duration = endTime - startTime;
                    
                    // Выбираем случайный эффект
                    var allEffects = effects.capcutEffects.concat(effects.motionEffects || []);
                    var selectedEffect = allEffects[Math.floor(Math.random() * allEffects.length)];
                    
                    switch(selectedEffect) {
                        case 'zoomBurst':
                            if (scaleParam) {
                                var burstDuration = duration * 0.2; // 20% времени на burst
                                var startScale = effects.zoomBurstStart || 150;
                                var decay = (effects.zoomBurstDecay || 80) / 100;
                                
                                // Быстрый зум в начале
                                scaleParam.addKey(startTime);
                                scaleParam.setValueAtKey(startTime, startScale);
                                
                                // Точка затухания
                                scaleParam.addKey(startTime + burstDuration);
                                scaleParam.setValueAtKey(startTime + burstDuration, 100 + (startScale - 100) * (1 - decay));
                                
                                // Медленное движение до конца
                                scaleParam.addKey(endTime);
                                scaleParam.setValueAtKey(endTime, 100);
                                
                                // Применяем кривую для первого участка
                                setKeyframeInterpolation(scaleParam, 0, 'ease-out');
                                setKeyframeInterpolation(scaleParam, 1, 'linear');
                            }
                            break;
                            
                        case 'pulse':
                            if (scaleParam) {
                                var amplitude = effects.scaleAmplitude / 100;
                                var pulseCount = Math.floor(duration * 2); // 2 пульсации в секунду
                                
                                for (var p = 0; p <= pulseCount; p++) {
                                    var time = startTime + (duration * p / pulseCount);
                                    scaleParam.addKey(time);
                                    
                                    // Чередуем масштаб
                                    var scale = p % 2 === 0 ? 100 : 100 + (20 * amplitude);
                                    scaleParam.setValueAtKey(time, scale);
                                }
                            }
                            break;
                            
                        case 'bounce':
                            if (scaleParam) {
                                var bounceHeight = effects.scaleAmplitude / 100;
                                var bounces = 3;
                                
                                scaleParam.addKey(startTime);
                                scaleParam.setValueAtKey(startTime, 100);
                                
                                for (var b = 1; b <= bounces; b++) {
                                    var bounceTime = startTime + (duration * b / (bounces + 1));
                                    var bounceScale = 100 + (30 * bounceHeight * (1 - b/bounces));
                                    
                                    scaleParam.addKey(bounceTime - 0.1);
                                    scaleParam.setValueAtKey(bounceTime - 0.1, bounceScale);
                                    
                                    scaleParam.addKey(bounceTime);
                                    scaleParam.setValueAtKey(bounceTime, 100);
                                }
                            }
                            break;
                            
                        case 'shake':
                            if (positionParam) {
                                var intensity = effects.motionIntensity / 1000;
                                var shakeFrames = 10;
                                
                                for (var s = 0; s < shakeFrames; s++) {
                                    var shakeTime = startTime + (duration * s / shakeFrames);
                                    var offsetX = (Math.random() - 0.5) * intensity;
                                    var offsetY = (Math.random() - 0.5) * intensity;
                                    
                                    positionParam.addKey(shakeTime);
                                    positionParam.setValueAtKey(shakeTime, [0.5 + offsetX, 0.5 + offsetY]);
                                }
                            }
                            break;
                            
                        case 'wobble':
                            if (rotationParam) {
                                var wobbleAngle = effects.motionIntensity / 10;
                                var wobbleCount = Math.floor(duration * 3);
                                
                                for (var w = 0; w <= wobbleCount; w++) {
                                    var wobbleTime = startTime + (duration * w / wobbleCount);
                                    var angle = Math.sin(w * Math.PI) * wobbleAngle;
                                    
                                    rotationParam.addKey(wobbleTime);
                                    rotationParam.setValueAtKey(wobbleTime, angle);
                                }
                            }
                            break;
                            
                        case 'pendulum':
                            if (rotationParam) {
                                var swingAngle = effects.motionIntensity / 5;
                                
                                rotationParam.addKey(startTime);
                                rotationParam.setValueAtKey(startTime, -swingAngle);
                                
                                rotationParam.addKey(startTime + duration/2);
                                rotationParam.setValueAtKey(startTime + duration/2, swingAngle);
                                
                                rotationParam.addKey(endTime);
                                rotationParam.setValueAtKey(endTime, -swingAngle);
                                
                                // Применяем ease-in-out для плавности
                                setKeyframeInterpolation(rotationParam, 0, 'ease-in-out');
                                setKeyframeInterpolation(rotationParam, 1, 'ease-in-out');
                            }
                            break;
                    }
                }
                
                function shouldApplyEffect(clipIndex, effects) {
                    var frequency = effects.effectFrequency || 'all';
                    
                    if (frequency === 'all') return true;
                    
                    if (frequency === 'percent') {
                        var percent = effects.effectPercent || 50;
                        return Math.random() * 100 < percent;
                    }
                    
                    if (frequency === 'every') {
                        var every = effects.effectEvery || 3;
                        return clipIndex % every === 0;
                    }
                    
                    if (frequency === 'random') {
                        return Math.random() > 0.5;
                    }
                    
                    return false;
                }
                
                function applyColorCorrection(clip, effects) {
                    // Находим или добавляем Lumetri Color
                    var lumetriEffect = null;
                    
                    for (var i = 0; i < clip.components.numItems; i++) {
                        if (clip.components[i].displayName === "Lumetri Color") {
                            lumetriEffect = clip.components[i];
                            break;
                        }
                    }
                    
                    if (!lumetriEffect) {
                        // Добавляем эффект
                        var videoEffects = app.project.rootItem.getVideoEffectByName("Lumetri Color");
                        if (videoEffects) {
                            clip.addVideoEffect(videoEffects);
                            
                            // Находим добавленный эффект
                            for (var j = 0; j < clip.components.numItems; j++) {
                                if (clip.components[j].displayName === "Lumetri Color") {
                                    lumetriEffect = clip.components[j];
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (!lumetriEffect || !lumetriEffect.properties) return;
                    
                    // Применяем настройки цветового фильтра
                    var filterPresets = {
                        'warm': {temperature: 20, tint: 5, saturation: 110},
                        'cold': {temperature: -20, tint: -5, saturation: 90},
                        'vintage': {temperature: 10, tint: 10, saturation: 80, fadeAmount: 10},
                        'blackwhite': {saturation: 0},
                        'sepia': {temperature: 30, tint: 15, saturation: 50},
                        'cinematic': {temperature: -10, contrast: 110, highlights: -20, shadows: 20, saturation: 95},
                        'vibrant': {vibrance: 130, saturation: 120},
                        'faded': {fadeAmount: 15, contrast: 90, saturation: 85}
                    };
                    
                    var preset = filterPresets[effects.colorFilter];
                    if (preset) {
                        for (var param in preset) {
                            setLumetriParam(lumetriEffect, param, preset[param]);
                        }
                    }
                    
                    // Виньетка
                    if (effects.vignette) {
                        var vignetteAmount = -(effects.vignetteIntensity / 100) * 2;
                        setLumetriParam(lumetriEffect, "vignetteAmount", vignetteAmount);
                    }
                    
                    // Зерно
                    if (effects.grain) {
                        // Добавляем эффект Noise
                        var noiseEffect = app.project.rootItem.getVideoEffectByName("Noise");
                        if (noiseEffect) {
                            clip.addVideoEffect(noiseEffect);
                            
                            // Настраиваем интенсивность
                            for (var k = 0; k < clip.components.numItems; k++) {
                                if (clip.components[k].displayName === "Noise") {
                                    var noiseComp = clip.components[k];
                                    var amountParam = noiseComp.properties.getParamForDisplayName("Amount of Noise");
                                    if (amountParam) {
                                        amountParam.setValue(effects.grainIntensity / 100 * 10);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
                
                function setLumetriParam(lumetriEffect, paramName, value) {
                    var properties = lumetriEffect.properties;
                    
                    // Маппинг имен параметров
                    var paramMap = {
                        'temperature': 'Temperature',
                        'tint': 'Tint',
                        'exposure': 'Exposure',
                        'contrast': 'Contrast',
                        'highlights': 'Highlights',
                        'shadows': 'Shadows',
                        'whites': 'Whites',
                        'blacks': 'Blacks',
                        'saturation': 'Saturation',
                        'vibrance': 'Vibrance',
                        'fadeAmount': 'Faded Film Amount',
                        'vignetteAmount': 'Vignette Amount'
                    };
                    
                    var displayName = paramMap[paramName];
                    if (!displayName) return;
                    
                    var param = properties.getParamForDisplayName(displayName);
                    if (param && !param.isTimeVarying()) {
                        param.setValue(value);
                    }
                }
                
                function apply3DEffects(clip, effects) {
                    if (effects.type3D === 'basic') {
                        // Используем Basic 3D эффект
                        var basic3D = app.project.rootItem.getVideoEffectByName("Basic 3D");
                        if (basic3D) {
                            clip.addVideoEffect(basic3D);
                            
                            // Находим добавленный эффект
                            for (var i = 0; i < clip.components.numItems; i++) {
                                if (clip.components[i].displayName === "Basic 3D") {
                                    var effect3D = clip.components[i];
                                    var intensity = effects.intensity3D / 100;
                                    
                                    // Анимируем поворот
                                    var tiltParam = effect3D.properties.getParamForDisplayName("Tilt");
                                    var swivelParam = effect3D.properties.getParamForDisplayName("Swivel");
                                    
                                    if (tiltParam && swivelParam) {
                                        var startTime = clip.inPoint.seconds;
                                        var endTime = clip.outPoint.seconds;
                                        
                                        if (effects.autoRotate3D) {
                                            // Автовращение
                                            swivelParam.addKey(startTime);
                                            swivelParam.setValueAtKey(startTime, -10 * intensity);
                                            swivelParam.addKey(endTime);
                                            swivelParam.setValueAtKey(endTime, 10 * intensity);
                                        } else {
                                            // Статичный 3D
                                            tiltParam.setValue(5 * intensity);
                                            swivelParam.setValue(8 * intensity);
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
>>>>>>> 5adb8a335390beae31960bdd51844c4147e887e1
                
                function addTransition(clip1, clip2, effects) {
                    var track = clip1.parentTrack;
                    if (!track) return;
                    
                    var transitions = effects.transitions || ['fade'];
                    var selectedTransition = effects.transRandomize ? 
                        transitions[Math.floor(Math.random() * transitions.length)] :
                        transitions[0];
                    
                    var duration = effects.transitionDuration || 1.0;
                    
                    // Маппинг имен переходов
                    var transitionMap = {
                        'fade': 'Dip to Black',
                        'dissolve': 'Cross Dissolve',
                        'dip_black': 'Dip to Black',
                        'dip_white': 'Dip to White',
                        'wipe': 'Linear Wipe',
                        'slide': 'Slide',
                        'push': 'Push',
                        'zoom': 'Cross Zoom'
                    };
                    
                    var transitionName = transitionMap[selectedTransition] || 'Cross Dissolve';
                    
                    // Применяем переход
                    var transition = track.getTransitionByName(transitionName);
                    if (transition) {
                        // Позиция перехода - между клипами
                        var transitionTime = clip1.outPoint.seconds - duration/2;
                        track.insertTransition(transition, transitionTime);
                        
                        // Настраиваем длительность
                        var addedTransition = track.transitions[track.transitions.numItems - 1];
                        if (addedTransition) {
                            addedTransition.duration = duration;
                        }
                    }
                }
                
                function addOverlays(sequence, overlaySettings, totalDuration) {
                    if (!overlaySettings.files || overlaySettings.files.length === 0) return;
                    
                    var videoTrack2 = sequence.videoTracks[1];
                    if (!videoTrack2) return;
                    
                    var currentTime = 0;
                    
                    while (currentTime < totalDuration) {
                        // Выбираем оверлей
                        var overlayFile = overlaySettings.randomize ?
                            overlaySettings.files[Math.floor(Math.random() * overlaySettings.files.length)] :
                            overlaySettings.files[currentTime % overlaySettings.files.length];
                        
                        // Находим в проекте
                        var overlayItem = findProjectItem(overlayFile);
                        if (!overlayItem) continue;
                        
                        // Добавляем на второй трек
                        var overlayClip = videoTrack2.insertClip(overlayItem, currentTime);
                        if (!overlayClip) continue;
                        
                        // Настраиваем наложение
                        var opacityEffect = null;
                        for (var i = 0; i < overlayClip.components.numItems; i++) {
                            if (overlayClip.components[i].displayName === "Opacity") {
                                opacityEffect = overlayClip.components[i];
                                break;
                            }
                        }
                        
                        if (opacityEffect) {
                            var opacityParam = opacityEffect.properties.getParamForDisplayName("Opacity");
                            if (opacityParam) {
                                opacityParam.setValue(overlaySettings.opacity);
                            }
                        }
                        
                        // Режим наложения
                        setBlendMode(overlayClip, overlaySettings.blendMode);
                        
                        // Растягивание
                        if (overlaySettings.stretch) {
                            // Растягиваем на весь кадр
                            var motionEffect = null;
                            for (var j = 0; j < overlayClip.components.numItems; j++) {
                                if (overlayClip.components[j].displayName === "Motion") {
                                    motionEffect = overlayClip.components[j];
                                    break;
                                }
                            }
                            
                            if (motionEffect) {
                                var scaleParam = motionEffect.properties.getParamForDisplayName("Scale");
                                if (scaleParam) {
                                    // Подгоняем под размер кадра
                                    scaleParam.setValue(120); // Немного больше для перекрытия
                                }
                            }
                        }
                        
                        currentTime += overlayClip.duration.seconds;
                    }
                }
                
                function setBlendMode(clip, mode) {
                    // В Premiere Pro режимы наложения устанавливаются через специальное свойство
                    // Это зависит от версии API
                    try {
                        var blendModeMap = {
                            'normal': 0,
                            'screen': 3,
                            'overlay': 9,
                            'multiply': 1,
                            'add': 2,
                            'lighten': 5,
                            'darken': 4
                        };
                        
                        var modeValue = blendModeMap[mode] || 0;
                        
                        // Попытка установить режим наложения
                        if (clip.setBlendMode) {
                            clip.setBlendMode(modeValue);
                        }
                    } catch(e) {
                        // Игнорируем если метод недоступен
                    }
                }
                
                function applyEasing(effect, easingType, bezierP1, bezierP2) {
                    // Применяем интерполяцию ко всем ключевым кадрам
                    if (!effect || !effect.properties) return;
                    
                    for (var i = 0; i < effect.properties.numItems; i++) {
                        var param = effect.properties[i];
                        if (param.isTimeVarying() && param.getKeys().length > 0) {
                            for (var k = 0; k < param.getKeys().length; k++) {
                                setKeyframeInterpolation(param, k, easingType, bezierP1, bezierP2);
                            }
                        }
                    }
                }
                
                function setKeyframeInterpolation(param, keyIndex, easingType, bezierP1, bezierP2) {
                    try {
                        // В Premiere Pro интерполяция устанавливается через временную интерполяцию
                        var key = param.getKeys()[keyIndex];
                        if (!key) return;
                        
                        switch(easingType) {
                            case 'linear':
                                param.setInterpolationTypeAtKey(key.time, KeyframeInterpolationType.LINEAR);
                                break;
                            case 'ease':
                            case 'ease-in-out':
                                param.setInterpolationTypeAtKey(key.time, KeyframeInterpolationType.BEZIER);
                                param.setTemporalEaseAtKey(key.time, [0.33], [0.33]);
                                break;
                            case 'ease-in':
                                param.setInterpolationTypeAtKey(key.time, KeyframeInterpolationType.BEZIER);
                                param.setTemporalEaseAtKey(key.time, [0.42], [0]);
                                break;
                            case 'ease-out':
                                param.setInterpolationTypeAtKey(key.time, KeyframeInterpolationType.BEZIER);
                                param.setTemporalEaseAtKey(key.time, [0], [0.58]);
                                break;
                            case 'bezier':
                                param.setInterpolationTypeAtKey(key.time, KeyframeInterpolationType.BEZIER);
                                var p1 = (bezierP1 || 25) / 100;
                                var p2 = (bezierP2 || 75) / 100;
                                param.setTemporalEaseAtKey(key.time, [p1], [p2]);
                                break;
                        }
                    } catch(e) {
                        // Игнорируем ошибки интерполяции
                    }
                }
            `;
        }

        // === НАСТРОЙКИ ===

        function loadSettings() {
            const stored = localStorage.getItem('autoMontageSettings');
            if (stored) {
                try {
                    const settings = JSON.parse(stored);
                    
                    document.getElementById('ffmpegPath').value = settings.ffmpegPath || 'ffmpeg.exe';
                    document.getElementById('amePath').value = settings.amePath || '';
                    document.getElementById('pythonPath').value = settings.pythonPath || 'python';
                    document.getElementById('renderThreads').value = settings.renderThreads || 4;
                    document.getElementById('renderThreadsValue').textContent = settings.renderThreads || 4;
                    document.getElementById('useGPU').checked = settings.useGPU !== false;
                    document.getElementById('useProxies').checked = settings.useProxies || false;
                    document.getElementById('preRenderEffects').checked = settings.preRenderEffects || false;
                    document.getElementById('transcodeRussian').checked = settings.transcodeRussian !== false;
                    document.getElementById('keepOriginals').checked = settings.keepOriginals !== false;
                    document.getElementById('cleanupTemp').checked = settings.cleanupTemp || false;
                    document.getElementById('autoSave').checked = settings.autoSave !== false;
                    document.getElementById('autoBackup').checked = settings.autoBackup || false;
                    document.getElementById('showNotifications').checked = settings.showNotifications !== false;
                } catch(e) {
                    log('Ошибка загрузки настроек: ' + e.message, 'warning');
                }
            }
            
            // Автопоиск программ
            findMediaEncoder();
        }

        function saveSettings() {
            const settings = {
                ffmpegPath: document.getElementById('ffmpegPath').value,
                amePath: document.getElementById('amePath').value,
                pythonPath: document.getElementById('pythonPath').value,
                renderThreads: parseInt(document.getElementById('renderThreads').value),
                useGPU: document.getElementById('useGPU').checked,
                useProxies: document.getElementById('useProxies').checked,
                preRenderEffects: document.getElementById('preRenderEffects').checked,
                transcodeRussian: document.getElementById('transcodeRussian').checked,
                keepOriginals: document.getElementById('keepOriginals').checked,
                cleanupTemp: document.getElementById('cleanupTemp').checked,
                autoSave: document.getElementById('autoSave').checked,
                autoBackup: document.getElementById('autoBackup').checked,
                showNotifications: document.getElementById('showNotifications').checked
            };
            
            localStorage.setItem('autoMontageSettings', JSON.stringify(settings));
            log('Настройки сохранены', 'info');
        }

        function resetSettings() {
            if (confirm('Сбросить все настройки к значениям по умолчанию?')) {
                localStorage.removeItem('autoMontageSettings');
                loadSettings();
                log('Настройки сброшены', 'info');
            }
        }

        function exportSettings() {
            const allSettings = {
                app: JSON.parse(localStorage.getItem('autoMontageSettings') || '{}'),
                channels: channels,
                version: '4.0.0'
            };
            
            const dataStr = JSON.stringify(allSettings, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = 'automontage_complete_settings_' + new Date().toISOString().slice(0, 10) + '.json';
            link.click();
            
            log('Все настройки экспортированы', 'info');
        }

        function importSettings() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const settings = JSON.parse(event.target.result);
                        
                        if (settings.app) {
                            localStorage.setItem('autoMontageSettings', JSON.stringify(settings.app));
                            loadSettings();
                        }
                        
                        if (settings.channels) {
                            channels = settings.channels;
                            saveChannels();
                            updateChannelLists();
                        }
                        
                        alert('Настройки успешно импортированы!');
                        log('Настройки импортированы', 'info');
                    } catch (err) {
                        alert('Ошибка импорта: ' + err.message);
                        log('Ошибка импорта настроек', 'error');
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }

        function browsePath(type) {
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                
                let filter = '';
                let title = '';
                
                switch(type) {
                    case 'ffmpeg':
                        filter = 'ffmpeg.exe';
                        title = 'Выберите ffmpeg.exe';
                        break;
                    case 'ame':
                        filter = 'Adobe Media Encoder.exe';
                        title = 'Выберите Adobe Media Encoder.exe';
                        break;
                    case 'python':
                        filter = 'python.exe';
                        title = 'Выберите python.exe';
                        break;
                }
                
                const extScript = `
                    var file = File.openDialog("${title}", "${filter}");
                    if (file) {
                        file.fsName;
                    } else {
                        null;
                    }
                `;
                
                csInterface.evalScript(extScript, function(result) {
                    if (result && result !== 'null') {
                        document.getElementById(`${type}Path`).value = result;
                        log(`Выбран путь ${type}: ${result}`, 'info');
                    }
                });
            } else {
                alert('Выбор файла доступен только в Premiere Pro');
            }
        }

        function findMediaEncoder() {
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                
                const extScript = `
                    function findAME() {
                        var paths = [
                            "C:/Program Files/Adobe/Adobe Media Encoder 2024/Adobe Media Encoder.exe",
                            "C:/Program Files/Adobe/Adobe Media Encoder 2023/Adobe Media Encoder.exe",
                            "C:/Program Files/Adobe/Adobe Media Encoder 2022/Adobe Media Encoder.exe",
                            "C:/Program Files/Adobe/Adobe Media Encoder CC 2020/Adobe Media Encoder.exe"
                        ];
                        
                        for (var i = 0; i < paths.length; i++) {
                            var file = new File(paths[i]);
                            if (file.exists) {
                                return paths[i];
                            }
                        }
                        
                        return "";
                    }
                    
                    findAME();
                `;
                
                csInterface.evalScript(extScript, function(result) {
                    if (result && result !== '""') {
                        document.getElementById('amePath').value = result;
                        log('Media Encoder найден автоматически', 'info');
                    }
                });
            }
        }

        function downloadFFmpeg() {
            window.open('https://ffmpeg.org/download.html', '_blank');
            log('Открыта страница загрузки FFmpeg', 'info');
        }

        function checkPython() {
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                const pythonPath = document.getElementById('pythonPath').value;
                
                const extScript = `
                    function checkPython(path) {
                        try {
                            var result = system.callSystem('"' + path + '" --version');
                            return "Python найден: " + result;
                        } catch(e) {
                            return "Python не найден или недоступен";
                        }
                    }
                    
                    checkPython("${pythonPath}");
                `;
                
                csInterface.evalScript(extScript, function(result) {
                    alert(result);
                    log(result, result.includes('найден') ? 'info' : 'warning');
                });
            } else {
                alert('Проверка доступна только в Premiere Pro');
            }
        }

        // === РАБОТА С ЭФФЕКТАМИ ===

        function loadChannelEffects() {
            const channelId = document.getElementById('channelSelector').value;
            if (!channelId) {
                document.getElementById('effectsEditor').style.display = 'none';
                return;
            }
            
            const channel = channels.find(c => c.id === channelId);
            if (!channel) return;
            
            currentChannelId = channelId;
            document.getElementById('effectsEditor').style.display = 'block';
            
            const effects = channel.effects;
            const exportSettings = channel.export;
            
            // Настройки экспорта
            document.getElementById('channelResolution').value = exportSettings.resolution || '1920x1080';
            document.getElementById('customResolution').style.display = 
                exportSettings.resolution === 'custom' ? 'block' : 'none';
            document.getElementById('customWidth').value = exportSettings.customWidth || 1920;
            document.getElementById('customHeight').value = exportSettings.customHeight || 1080;
            document.getElementById('channelFps').value = exportSettings.fps || 30;
            document.getElementById('channelBitrate').value = exportSettings.bitrate || 8;
            document.getElementById('channelCodec').value = exportSettings.codec || 'h264';
            
            // Ken Burns
            document.querySelectorAll('.kb-effect').forEach(cb => {
                const effectName = cb.id.replace('kb_', '');
                cb.checked = effects.kenBurns && effects.kenBurns.includes(effectName);
            });
            document.getElementById('kbIntensity').value = effects.kenBurnsIntensity || 30;
            document.getElementById('kbIntensityValue').textContent = (effects.kenBurnsIntensity || 30) + '%';
            document.getElementById('rotationAngle').value = effects.rotationAngle || 5;
            document.getElementById('rotationAngleValue').textContent = (effects.rotationAngle || 5) + '°';
            document.getElementById('kbSmartCrop').checked = effects.smartCrop !== false;
            document.getElementById('kbRandomize').checked = effects.kbRandomize || false;
            
            // Переходы
            document.querySelectorAll('.transition-effect').forEach(cb => {
                const effectName = cb.id.replace('trans_', '');
                cb.checked = effects.transitions && effects.transitions.includes(effectName);
            });
            document.getElementById('transitionDuration').value = effects.transitionDuration || 1.0;
            document.getElementById('transRandomize').checked = effects.transRandomize || false;
            
            // Цветокоррекция
            document.getElementById('enableColorCorrection').checked = effects.colorCorrection || false;
            document.getElementById('colorCorrectionSettings').style.display = effects.colorCorrection ? 'block' : 'none';
            document.getElementById('colorFilter').value = effects.colorFilter || 'none';
            document.getElementById('enableVignette').checked = effects.vignette || false;
            document.getElementById('vignetteSettings').style.display = effects.vignette ? 'block' : 'none';
            document.getElementById('vignetteIntensity').value = effects.vignetteIntensity || 40;
            document.getElementById('vignetteIntensityValue').textContent = (effects.vignetteIntensity || 40) + '%';
            document.getElementById('enableGrain').checked = effects.grain || false;
            document.getElementById('grainSettings').style.display = effects.grain ? 'block' : 'none';
            document.getElementById('grainIntensity').value = effects.grainIntensity || 20;
            document.getElementById('grainIntensityValue').textContent = (effects.grainIntensity || 20) + '%';
            
            // Аудио
            document.getElementById('audioPitch').value = effects.audioPitch || '0';
            document.getElementById('audioEffect').value = effects.audioEffect || 'none';
            document.getElementById('audioStereoEnhance').checked = effects.audioStereoEnhance || false;
            document.getElementById('audioNormalize').checked = effects.audioNormalize !== false;
            
            // Плавность
            document.getElementById('easingType').value = effects.easingType || 'ease';
            document.getElementById('bezierSettings').style.display = effects.easingType === 'bezier' ? 'block' : 'none';
            document.getElementById('bezierP1').value = effects.bezierP1 || 25;
            document.getElementById('bezierP1Value').textContent = effects.bezierP1 || 25;
            document.getElementById('bezierP2').value = effects.bezierP2 || 75;
            document.getElementById('bezierP2Value').textContent = effects.bezierP2 || 75;
            
            // 3D
            document.getElementById('enable3D').checked = effects.enable3D || false;
            document.getElementById('3dSettings').style.display = effects.enable3D ? 'block' : 'none';
            document.getElementById('3dType').value = effects.type3D || 'basic';
            document.getElementById('3dIntensity').value = effects.intensity3D || 20;
            document.getElementById('3dIntensityValue').textContent = (effects.intensity3D || 20) + '%';
            document.getElementById('3dAutoRotate').checked = effects.autoRotate3D || false;
        }

        function saveChannelEffects() {
            if (!currentChannelId) return;
            
            const channel = channels.find(c => c.id === currentChannelId);
            if (!channel) return;
            
            // Собираем настройки экспорта
            const exportSettings = {
                resolution: document.getElementById('channelResolution').value,
                customWidth: parseInt(document.getElementById('customWidth').value),
                customHeight: parseInt(document.getElementById('customHeight').value),
                fps: parseInt(document.getElementById('channelFps').value),
                bitrate: parseInt(document.getElementById('channelBitrate').value),
                codec: document.getElementById('channelCodec').value
            };
            
            // Собираем все эффекты
            const effects = {
                // Ken Burns
                kenBurns: [],
                kenBurnsIntensity: parseInt(document.getElementById('kbIntensity').value),
                rotationAngle: parseInt(document.getElementById('rotationAngle').value),
                smartCrop: document.getElementById('kbSmartCrop').checked,
                kbRandomize: document.getElementById('kbRandomize').checked,
                
                // Переходы
                transitions: [],
                transitionDuration: parseFloat(document.getElementById('transitionDuration').value),
                transRandomize: document.getElementById('transRandomize').checked,
                
                // Цветокоррекция
                colorCorrection: document.getElementById('enableColorCorrection').checked,
                colorFilter: document.getElementById('colorFilter').value,
                vignette: document.getElementById('enableVignette').checked,
                vignetteIntensity: parseInt(document.getElementById('vignetteIntensity').value),
                grain: document.getElementById('enableGrain').checked,
                grainIntensity: parseInt(document.getElementById('grainIntensity').value),
                
                // Аудио
                audioPitch: document.getElementById('audioPitch').value,
                audioEffect: document.getElementById('audioEffect').value,
                audioStereoEnhance: document.getElementById('audioStereoEnhance').checked,
                audioNormalize: document.getElementById('audioNormalize').checked,
                
                // Плавность
                easingType: document.getElementById('easingType').value,
                bezierP1: parseInt(document.getElementById('bezierP1').value),
                bezierP2: parseInt(document.getElementById('bezierP2').value),
                
                // 3D
                enable3D: document.getElementById('enable3D').checked,
                type3D: document.getElementById('3dType').value,
                intensity3D: parseInt(document.getElementById('3dIntensity').value),
                autoRotate3D: document.getElementById('3dAutoRotate').checked
            };
            
            // Собираем выбранные эффекты
            document.querySelectorAll('.kb-effect:checked').forEach(cb => {
                effects.kenBurns.push(cb.id.replace('kb_', ''));
            });
            
            document.querySelectorAll('.transition-effect:checked').forEach(cb => {
                effects.transitions.push(cb.id.replace('trans_', ''));
            });
            
            // Сохраняем старые настройки CapCut эффектов
            if (channel.effects.capcutEffects) {
                effects.capcutEffects = channel.effects.capcutEffects;
                effects.scaleAmplitude = channel.effects.scaleAmplitude;
                effects.zoomBurstStart = channel.effects.zoomBurstStart;
                effects.zoomBurstDecay = channel.effects.zoomBurstDecay;
                effects.motionEffects = channel.effects.motionEffects;
                effects.motionIntensity = channel.effects.motionIntensity;
                effects.effectFrequency = channel.effects.effectFrequency;
                effects.effectPercent = channel.effects.effectPercent;
                effects.effectEvery = channel.effects.effectEvery;
                effects.avoidRepetition = channel.effects.avoidRepetition;
            }
            
            // Сохраняем
            channel.export = exportSettings;
            channel.effects = effects;
            saveChannels();
            log(`Настройки канала "${channel.name}" сохранены`, 'info');
        }

        function resetChannelEffects() {
            if (!currentChannelId) return;
            
            if (confirm('Сбросить все настройки эффектов к значениям по умолчанию?')) {
                loadChannelEffects();
                log('Настройки сброшены', 'info');
            }
        }

        function previewEffects() {
            alert('Предпросмотр будет реализован в следующей версии');
        }

        function duplicateToChannel() {
            if (!currentChannelId) return;
            
            const sourceChannel = channels.find(c => c.id === currentChannelId);
            if (!sourceChannel) return;
            
            const channelNames = channels
                .filter(c => c.id !== currentChannelId)
                .map(c => c.name)
                .join('\n');
            
            const targetName = prompt(`Копировать настройки в канал:\n\n${channelNames}\n\nВведите название канала:`);
            if (!targetName) return;
            
            const targetChannel = channels.find(c => c.name === targetName && c.id !== currentChannelId);
            if (!targetChannel) {
                alert('Канал не найден!');
                return;
            }
            
            targetChannel.effects = JSON.parse(JSON.stringify(sourceChannel.effects));
            targetChannel.export = JSON.parse(JSON.stringify(sourceChannel.export));
            saveChannels();
            log(`Настройки скопированы в канал "${targetName}"`, 'info');
        }

        // === РАБОТА С ОВЕРЛЕЯМИ ===

        function selectOverlaysFolder() {
            // Проверяем среду выполнения
            if (window.cep && window.cep.fs) {
                // CEP окружение
                const result = window.cep.fs.showOpenDialogEx(false, true, "Выберите папку с оверлеями", "");
                if (result.data && result.data.length > 0) {
                    OVERLAYS_FOLDER = result.data[0];
                    document.getElementById('overlaysPath').value = OVERLAYS_FOLDER;
                    scanOverlaysFolder();
                }
            } else {
                // Браузерный режим - симуляция
                const simulatedPath = prompt("Введите путь к папке с оверлеями:", "C:/Overlays");
                if (simulatedPath) {
                    OVERLAYS_FOLDER = simulatedPath;
                    document.getElementById('overlaysPath').value = simulatedPath;
                    
                    // Симуляция файлов оверлеев
                    overlayFiles = [
                        {name: 'particles.mp4', type: 'video'},
                        {name: 'film_grain.mov', type: 'video'},
                        {name: 'light_leak.mp4', type: 'video'},
                        {name: 'frame_vintage.png', type: 'image'},
                        {name: 'dust.mp4', type: 'video'}
                    ];
                    
                    log(`Найдено оверлеев: ${overlayFiles.length}`, 'info');
                }
            }
        }

        function scanOverlaysFolder() {
            if (!OVERLAYS_FOLDER) return;
            
            const extScript = `
                function scanOverlays(folderPath) {
                    try {
                        var folder = new Folder(folderPath);
                        if (!folder.exists) return {files: [], error: "Папка не существует"};
                        
                        var overlays = [];
                        var files = folder.getFiles();
                        var supportedFormats = ['.mp4', '.mov', '.avi', '.png', '.gif'];
                        
                        for (var i = 0; i < files.length; i++) {
                            if (files[i] instanceof File) {
                                var fileName = files[i].name;
                                var ext = fileName.substr(fileName.lastIndexOf('.')).toLowerCase();
                                
                                if (supportedFormats.indexOf(ext) > -1) {
                                    var type = (ext === '.png' || ext === '.gif') ? 'image' : 'video';
                                    overlays.push({
                                        name: fileName,
                                        path: files[i].fsName,
                                        type: type
                                    });
                                }
                            }
                        }
                        
                        return {files: overlays};
                        
                    } catch(e) {
                        return {files: [], error: e.toString()};
                    }
                }
                
                JSON.stringify(scanOverlays("${OVERLAYS_FOLDER.replace(/\\/g, '\\\\')}"));
            `;
            
            if (typeof CSInterface !== 'undefined') {
                const csInterface = new CSInterface();
                csInterface.evalScript(extScript, function(result) {
                    try {
                        const scanResult = JSON.parse(result);
                        overlayFiles = scanResult.files;
                        log(`Найдено оверлеев: ${overlayFiles.length}`, 'info');
                    } catch(e) {
                        log('Ошибка сканирования оверлеев: ' + e.message, 'error');
                    }
                });
            }
        }

        function loadChannelOverlays() {
            const channelId = document.getElementById('overlayChannelSelector').value;
            if (!channelId) {
                document.getElementById('overlaySettings').style.display = 'none';
                return;
            }
            
            const channel = channels.find(c => c.id === channelId);
            if (!channel) return;
            
            document.getElementById('overlaySettings').style.display = 'block';
            
            // Отображаем список оверлеев
            const overlaysList = document.getElementById('overlaysList');
            overlaysList.innerHTML = '';
            
            if (!overlayFiles || overlayFiles.length === 0) {
                overlaysList.innerHTML = '<div class="info-text">Сначала выберите папку с оверлеями</div>';
                return;
            }
            
            overlayFiles.forEach((overlay, index) => {
                const item = document.createElement('div');
                item.className = 'effect-item';
                item.innerHTML = `
                    <input type="checkbox" id="overlay_${index}" class="overlay-file" data-name="${overlay.name}">
                    <label for="overlay_${index}">
                        ${overlay.type === 'video' ? '🎬' : '🖼️'} ${overlay.name}
                    </label>
                `;
                overlaysList.appendChild(item);
            });
            
            // Загружаем сохраненные настройки
            if (channel.overlays) {
                document.getElementById('overlayBlendMode').value = channel.overlays.blendMode || 'screen';
                document.getElementById('overlayOpacity').value = channel.overlays.opacity || 100;
                document.getElementById('overlayOpacityValue').textContent = (channel.overlays.opacity || 100) + '%';
                document.getElementById('overlayRandomize').checked = channel.overlays.randomize || false;
                document.getElementById('overlayStretch').checked = channel.overlays.stretch !== false;
                
                // Отмечаем выбранные файлы
                if (channel.overlays.files) {
                    channel.overlays.files.forEach(fileName => {
                        const checkbox = document.querySelector(`.overlay-file[data-name="${fileName}"]`);
                        if (checkbox) checkbox.checked = true;
                    });
                }
            }
        }

        function saveOverlaySettings() {
            const channelId = document.getElementById('overlayChannelSelector').value;
            if (!channelId) return;
            
            const channel = channels.find(c => c.id === channelId);
            if (!channel) return;
            
            const selectedFiles = [];
            document.querySelectorAll('.overlay-file:checked').forEach(cb => {
                selectedFiles.push(cb.dataset.name);
            });
            
            channel.overlays = {
                enabled: selectedFiles.length > 0,
                files: selectedFiles,
                blendMode: document.getElementById('overlayBlendMode').value,
                opacity: parseInt(document.getElementById('overlayOpacity').value),
                randomize: document.getElementById('overlayRandomize').checked,
                stretch: document.getElementById('overlayStretch').checked
            };
            
            saveChannels();
            updateChannelLists();
            log(`Настройки оверлеев для канала "${channel.name}" сохранены`, 'info');
        }

        // === CAPCUT ЭФФЕКТЫ ===

        function loadChannelCapcutEffects() {
            const channelId = document.getElementById('capcutChannelSelector').value;
            if (!channelId) {
                document.getElementById('capcutEffectsEditor').style.display = 'none';
                return;
            }
            
            const channel = channels.find(c => c.id === channelId);
            if (!channel) return;
            
            document.getElementById('capcutEffectsEditor').style.display = 'block';
            
            const effects = channel.effects;
            
            // Анимации масштаба
            document.querySelectorAll('.capcut-effect').forEach(cb => {
                const effectName = cb.id.replace('fx_', '');
                cb.checked = effects.capcutEffects && effects.capcutEffects.includes(effectName);
            });
            
            document.getElementById('scaleAmplitude').value = effects.scaleAmplitude || 15;
            document.getElementById('scaleAmplitudeValue').textContent = (effects.scaleAmplitude || 15) + '%';
            document.getElementById('zoomBurstStart').value = effects.zoomBurstStart || 150;
            document.getElementById('zoomBurstStartValue').textContent = (effects.zoomBurstStart || 150) + '%';
            document.getElementById('zoomBurstDecay').value = effects.zoomBurstDecay || 80;
            document.getElementById('zoomBurstDecayValue').textContent = (effects.zoomBurstDecay || 80) + '%';
            
            document.getElementById('motionIntensity').value = effects.motionIntensity || 30;
            document.getElementById('motionIntensityValue').textContent = (effects.motionIntensity || 30) + '%';
            
            // Частота применения
            document.getElementById('effectFrequency').value = effects.effectFrequency || 'all';
            document.getElementById('effectPercent').value = effects.effectPercent || 50;
            document.getElementById('effectPercentValue').textContent = (effects.effectPercent || 50) + '%';
            document.getElementById('effectEvery').value = effects.effectEvery || 3;
            document.getElementById('avoidRepetition').checked = effects.avoidRepetition !== false;
            
            // Показываем/скрываем настройки частоты
            const freq = effects.effectFrequency || 'all';
            document.getElementById('percentSettings').style.display = freq === 'percent' ? 'block' : 'none';
            document.getElementById('everySettings').style.display = freq === 'every' ? 'block' : 'none';
        }

        function saveCapcutEffects() {
            const channelId = document.getElementById('capcutChannelSelector').value;
            if (!channelId) return;
            
            const channel = channels.find(c => c.id === channelId);
            if (!channel) return;
            
            const capcutEffects = [];
            const motionEffects = [];
            
            document.querySelectorAll('.capcut-effect:checked').forEach(cb => {
                const effectName = cb.id.replace('fx_', '');
                if (['zoomBurst', 'pulse', 'bounce', 'elastic', 'wave'].includes(effectName)) {
                    capcutEffects.push(effectName);
                } else {
                    motionEffects.push(effectName);
                }
            });
            
            channel.effects.capcutEffects = capcutEffects;
            channel.effects.motionEffects = motionEffects;
            channel.effects.scaleAmplitude = parseInt(document.getElementById('scaleAmplitude').value);
            channel.effects.zoomBurstStart = parseInt(document.getElementById('zoomBurstStart').value);
            channel.effects.zoomBurstDecay = parseInt(document.getElementById('zoomBurstDecay').value);
            channel.effects.motionIntensity = parseInt(document.getElementById('motionIntensity').value);
            channel.effects.effectFrequency = document.getElementById('effectFrequency').value;
            channel.effects.effectPercent = parseInt(document.getElementById('effectPercent').value);
            channel.effects.effectEvery = parseInt(document.getElementById('effectEvery').value);
            channel.effects.avoidRepetition = document.getElementById('avoidRepetition').checked;
            
            saveChannels();
            updateChannelLists();
            log(`CapCut эффекты для канала "${channel.name}" сохранены`, 'info');
        }

        function presetCapcutEffects(presetType) {
            const presets = {
                dynamic: {
                    capcutEffects: ['zoomBurst', 'bounce'],
                    motionEffects: ['shake', 'wobble'],
                    scaleAmplitude: 25,
                    motionIntensity: 40,
                    effectFrequency: 'percent',
                    effectPercent: 60
                },
                smooth: {
                    capcutEffects: ['pulse', 'wave'],
                    motionEffects: ['pendulum'],
                    scaleAmplitude: 10,
                    motionIntensity: 20,
                    effectFrequency: 'every',
                    effectEvery: 3
                },
                epic: {
                    capcutEffects: ['zoomBurst', 'elastic'],
                    motionEffects: ['shake', 'glitch'],
                    scaleAmplitude: 30,
                    zoomBurstStart: 180,
                    zoomBurstDecay: 90,
                    motionIntensity: 50,
                    effectFrequency: 'all'
                }
            };
            
            const preset = presets[presetType];
            if (!preset) return;
            
            // Применяем пресет
            document.querySelectorAll('.capcut-effect').forEach(cb => {
                const effectName = cb.id.replace('fx_', '');
                cb.checked = preset.capcutEffects.includes(effectName) || preset.motionEffects.includes(effectName);
            });
            
            if (preset.scaleAmplitude !== undefined) {
                document.getElementById('scaleAmplitude').value = preset.scaleAmplitude;
                document.getElementById('scaleAmplitudeValue').textContent = preset.scaleAmplitude + '%';
            }
            
            if (preset.zoomBurstStart !== undefined) {
                document.getElementById('zoomBurstStart').value = preset.zoomBurstStart;
                document.getElementById('zoomBurstStartValue').textContent = preset.zoomBurstStart + '%';
            }
            
            if (preset.zoomBurstDecay !== undefined) {
                document.getElementById('zoomBurstDecay').value = preset.zoomBurstDecay;
                document.getElementById('zoomBurstDecayValue').textContent = preset.zoomBurstDecay + '%';
            }
            
            if (preset.motionIntensity !== undefined) {
                document.getElementById('motionIntensity').value = preset.motionIntensity;
                document.getElementById('motionIntensityValue').textContent = preset.motionIntensity + '%';
            }
            
            document.getElementById('effectFrequency').value = preset.effectFrequency || 'all';
            
            // Обновляем видимость настроек частоты
            document.getElementById('percentSettings').style.display = preset.effectFrequency === 'percent' ? 'block' : 'none';
            document.getElementById('everySettings').style.display = preset.effectFrequency === 'every' ? 'block' : 'none';
            
            if (preset.effectPercent !== undefined) {
                document.getElementById('effectPercent').value = preset.effectPercent;
                document.getElementById('effectPercentValue').textContent = preset.effectPercent + '%';
            }
            
            if (preset.effectEvery !== undefined) {
                document.getElementById('effectEvery').value = preset.effectEvery;
            }
            
            log(`Применен пресет CapCut эффектов: ${presetType}`, 'info');
        }
    </script>
</body>

</html>


